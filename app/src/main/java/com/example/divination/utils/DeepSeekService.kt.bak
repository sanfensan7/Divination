package com.example.divination.utils

import android.content.Context
import android.util.Log
import android.widget.Toast
import com.example.divination.model.DivinationMethod
import com.example.divination.model.DivinationResult
import com.example.divination.model.ResultSection
import org.json.JSONArray
import org.json.JSONObject
import java.io.BufferedReader
import java.io.DataOutputStream
import java.io.InputStreamReader
import java.net.HttpURLConnection
import java.net.URL
import java.nio.charset.StandardCharsets
import java.util.*
import javax.net.ssl.HttpsURLConnection
import kotlin.concurrent.thread
import kotlin.math.max
import java.util.regex.Pattern

/**
 * DeepSeek API服务类
 */
object DeepSeekService {
    
    private const val TAG = "DeepSeekService"
    private const val API_URL = "https://api.deepseek.com/v1/chat/completions"  // DeepSeek API地址
    
    // 从本地存储获取API密钥
    private fun getApiKey(context: Context): String {
        val prefs = context.getSharedPreferences("divination_prefs", Context.MODE_PRIVATE)
        val apiKey = prefs.getString("api_key", "") ?: ""
        
        // 检查并清理API密钥中可能的非法字符（如换行符等）
        return apiKey.trim().replace(Regex("\\s+"), "")
    }
    
    /**
     * 执行算命请求
     * 
     * @param context 上下文
     * @param method 算命方法
     * @param inputData 输入数据
     * @param callback 结果回调
     */
    fun performDivination(
        context: Context,
        method: DivinationMethod,
        inputData: Map<String, String>,
        callback: (DivinationResult?, Exception?) -> Unit
    ) {
        // 在后台线程执行网络请求
        thread {
            try {
                // 构建提示词
                val prompt = generatePrompt(method, inputData)
                
                // 检查API密钥
                val apiKey = getApiKey(context)
                if (apiKey.isEmpty()) {
                    // API密钥未设置，使用模拟响应并显示提示
                    showToast(context, "API密钥未设置，使用本地模拟模式")
                    Log.i(TAG, "API密钥未设置，使用本地模拟模式")
                    
                    // 创建模拟响应
                    val response = simulateResponse(prompt)
                    
                    // 添加模拟标记和解析响应
                    val simulatedSection = ResultSection(
                        title = "⚠️ 本地模拟提示",
                        content = "本次结果由本地算法模拟生成，非DeepSeek AI服务输出。为获取更专业、更个性化的AI算命结果，请在设置中配置有效的API密钥。\n\n高质量的AI算命结果将包含更丰富的专业分析和更个性化的解读。"
                    )
                    val sections = parseResponseToSections(response)
                    val result = DivinationResult(
                        id = UUID.randomUUID().toString(),
                        methodId = method.id,
                        createTime = Date(),
                        inputData = inputData,
                        resultSections = listOf(simulatedSection) + sections
                    )
                    
                    // 回调主线程
                    android.os.Handler(context.mainLooper).post {
                        callback(result, null)
                    }
                    return@thread
                }
                
                try {
                    // 尝试发送API请求
                    showToast(context, "正在连接AI服务...")
                    val response = sendRequest(context, apiKey, prompt)
                    
                    // 解析响应
                    val result = parseResponse(method, inputData, response)
                    
                    // 回调主线程
                    android.os.Handler(context.mainLooper).post {
                        callback(result, null)
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "API调用失败", e)
                    
                    // 使用模拟响应作为备选
                    showToast(context, "AI服务调用失败：${e.message?.take(50)}...，使用本地模拟模式")
                    
                    // 创建模拟响应
                    val response = simulateResponse(prompt)
                    
                    // 添加模拟标记和解析响应
                    val errorSection = ResultSection(
                        title = "⚠️ AI服务连接失败",
                        content = "DeepSeek AI服务调用失败：${e.message}\n\n系统已自动切换到本地算法模拟模式，但分析深度和个性化程度将受限。\n\n可能原因：\n1. 网络连接不稳定\n2. API密钥无效或已过期\n3. API服务暂时不可用\n\n建议：检查网络连接并在设置中更新API密钥。"
                    )
                    val sections = parseResponseToSections(response)
                    val result = DivinationResult(
                        id = UUID.randomUUID().toString(),
                        methodId = method.id,
                        createTime = Date(),
                        inputData = inputData,
                        resultSections = listOf(errorSection) + sections
                    )
                    
                    // 回调主线程
                    android.os.Handler(context.mainLooper).post {
                        callback(result, null)
                    }
                }
                
            } catch (e: Exception) {
                Log.e(TAG, "算命请求失败", e)
                
                // 回调主线程
                android.os.Handler(context.mainLooper).post {
                    callback(null, e)
                }
            }
        }
    }
    
    /**
     * 显示提示消息
     */
    private fun showToast(context: Context, message: String) {
        android.os.Handler(context.mainLooper).post {
            Toast.makeText(context, message, Toast.LENGTH_LONG).show()
        }
    }
    
    /**
     * 生成DeepSeek提示词
     */
    private fun generatePrompt(method: DivinationMethod, inputData: Map<String, String>): String {
        val basePrompt = """
        你是一位精通中国传统和西方占卜术的资深算命大师，拥有30年实践经验。
        请根据以下信息，生成一份详细、专业且符合文化背景的${method.name}分析结果：
        
        ## 分析背景
        - 分析方法：${method.name}（${if (method.type == 1) "中国传统" else "西方传统"}）
        - 分析目的：提供准确、有深度的命运解读，帮助用户理解自身状况和未来发展
        - 分析特点：结合传统理论与现代心理学，既尊重传统又符合现代人思维
        
        ## 用户输入信息
        ${inputData.entries.joinToString("\n") { "- ${it.key}: ${it.value}" }}
        
        ## 输出要求
        1. 内容分为至少4-5个独立章节，每章节有明确标题和详细解读
        2. 整体分析长度应在1200-2000字之间，内容丰富且专业
        3. 前面章节必须使用大量专业术语和深度分析，展示你的专业性和权威性
           - 要大量使用行业专业术语，尽可能展现深奥晦涩的分析风格
           - 引用经典著作和理论，使用专业的引用格式和术语解释
           - 分析必须详尽深入，使用完整的理论框架，展示分析的系统性和专业性
        4. 必须包含传统文化元素、术语和典故，配合专业理论分析
        5. 分析必须全面平衡，既指出积极优势，也要直接指出潜在问题、性格弱点和需要注意的风险
        6. 避免极端负面预测（如灾难、死亡等），但应指出若不改变会带来的实际挑战和后果
        7. 给予具体建议时，应包含规避风险、克服弱点的实际方法，至少3-5条
        8. 在适当位置引用传统经典语句增加可信度和深度
        9. 最后必须添加一个【总结】部分，与前面的专业分析形成鲜明对比：
           - 使用非常通俗易懂的语言，像与朋友对话一样，简明扼要地总结关键点
           - 完全避免任何专业术语，确保普通人也能轻松理解
           - 使用日常对话风格，就像朋友间聊天那样自然随意
           - 总结部分应当是独立的，即使不看前面的专业分析，也能明白主要结论
           - 总结应包含对用户情况的关键洞察和最重要的建议，但用最简单的语言表达
        
        ## 特殊要求
        ${getMethodSpecificPrompt(method.id)}
        
        请确保分析符合${method.name}的核心理论和方法论，不要混入其他占卜体系的元素。
        分析应具有个性化和针对性，避免空泛、模糊的表述。
        提供的建议应当实用、可操作，既有正面引导也有问题警示。
        前面的章节要展示你作为专业大师的深奥知识和洞察力，使用专业行话，而总结部分则要用外行人容易理解的白话，像老朋友一样直接聊天。
        """
        
        return basePrompt
    }
    
    /**
     * 根据不同算命方法获取特定提示词补充
     */
    private fun getMethodSpecificPrompt(methodId: String): String {
        return when (methodId) {
            "bazi" -> """
                - 必须按照天干地支理论分析八字四柱（年柱、月柱、日柱、时柱）
                - 详细解读用户五行强弱、日主特质、大运走向和流年影响
                - 分析命局中的喜用神与忌神，提出趋吉避凶的方法
                - 解释十神关系如正官、七杀、正印、偏印等在命局中的作用
                - 评估日主与各柱之间的关系，分析财、官、印、食等方面的表现
                - 包含传统五行相生相克理论对人生的影响
                - 指出命局中的冲克、刑害关系及其可能带来的挑战
                - 说明大运流年对命局的影响，包括顺逆运势的客观分析
                - 提出针对命局弱点的调整方法，如调整五行、选择适当的方位等
            """
            
            "ziwei" -> """
                - 必须基于紫微斗数十四主星和诸多辅星的组合与飞化
                - 详细分析十二宫位（命宫、财帛宫、兄弟宫、夫妻宫等）的主星组合
                - 解读四化星（化科、化禄、化权、化忌）对命盘的影响
                - 评估三方四正的吉凶格局
                - 分析大限、小限的流年运势变化
                - 重点解读命宫、身宫的星曜组合对性格的影响
                - 详细说明各宫位主管事项的发展情况
                - 直接指出各宫位中不利星曜的作用及其可能带来的挑战
                - 解释命盘中的煞星组合，如擎羊、陀罗、火星、铃星等的不利影响
                - 提供如何通过后天努力减轻不利星曜影响的建议
            """
            
            "qimen" -> """
                - 依据奇门遁甲九宫八门九星理论进行分析
                - 详细解读所在局的天盘、地盘、人盘三盘关系
                - 分析值符、值使所在宫位及其表现
                - 解释九星（天蓬、天任、天冲等）与八门（休、生、伤、杜等）的组合
                - 评估八神（值符、腾蛇、太阴等）在盘中的吉凶
                - 针对用户关注事项，分析适用宫位的吉凶与趋势
                - 说明三奇六仪太阳星的落宫对大局的影响
                - 明确指出盘中的凶门、煞神所在位置及其不利影响
                - 分析门户冲克关系带来的潜在问题
                - 建议如何趋吉避凶，规避盘中不利因素
            """
            
            "astrology" -> """
                - 必须首先提供星盘图的详细文字描述，以便我们能在APP中还原星盘图，请使用以下格式：
                  * 太阳位于白羊座15度
                  * 月亮位于金牛座10度
                  * 水星位于双子座5度
                  * 金星位于处女座20度
                  * 火星位于天秤座15度
                  * 木星位于天蝎座30度
                  * 土星位于金牛座0度
                  * 天王星位于双子座15度
                  * 海王星位于双鱼座0度
                  * 冥王星位于摩羯座0度
                  * 上升点位于白羊座0度
                  * 中天点位于摩羯座0度
                  (必须包含以上所有行星位置和度数)
                - 必须详细描述行星之间的相位关系，使用以下格式：
                  * 太阳和木星形成三分相(120度)
                  * 太阳和土星形成对分相(180度)
                  * 火星和冥王星形成四分相(90度)
                  * 金星和海王星形成六分相(60度)
                  (至少列出5个主要相位)
                - 详细分析太阳星座、月亮星座、上升星座三大主要星座特质
                - 解读十大行星在各宫位的影响和相位关系
                - 分析命盘中的相位组合（三分相、六分相、四分相、合相等）
                - 解释北交点、南交点对灵魂使命的启示
                - 评估命盘中的元素平衡（火、地、风、水）
                - 分析命盘中的主要格局和星盘形状（大三角、T十字等）
                - 结合用户当前的行运和进行相位分析
                - 详细解读不利相位（如四分相、对分相）的挑战和潜在问题
                - 分析受克制的行星及其可能导致的人生困境
                - 说明命盘中的缺失元素或弱势宫位带来的不平衡
                - 提供如何通过意识和行动弥补星盘缺陷的建议
            """
            
            "tarot" -> """
                - 详细解读每张塔罗牌的象征意义和牌面故事
                - 分析牌阵中的相互关系和整体故事线
                - 针对每个位置的牌义进行专业诠释（过去、现在、未来等）
                - 解释正位与逆位的不同含义
                - 分析大阿卡纳牌与小阿卡纳牌的不同侧重
                - 结合牌面元素（数字、符号、颜色）进行多层次解读
                - 对牌阵整体趋势给予清晰总结
                - 包含塔罗经典理论和心理学元素的专业解析
                - 直接解读牌阵中的负面牌（如死神、塔、恶魔等）的警示意义
                - 指出逆位牌所代表的具体挑战和阻碍
                - 分析牌阵中的不协调关系和潜在冲突
                - 在建议中包含如何应对负面牌预示的困境
            """
            
            "face" -> """
                - 基于传统面相学五官与命运关系的分析
                - 详细解读额头（天庭）、眉毛、眼睛、鼻子、嘴巴、下巴（地阁）等特征
                - 分析面部气色、痣点、纹理对运势的影响
                - 根据三停五岳理论评估面相整体平衡
                - 解释耳朵、眉毛等细节特征的命理含义
                - 分析面相中的财富线、婚姻线、事业线等特征
                - 结合传统相学与现代面部特征研究
                - 提供面相改善的建议（如提升气色、注意健康等）
                - 指出五官中的不协调特征及其反映的性格弱点
                - 解读面相中的"破绽"和"缺陷"对运势的影响
                - 分析面部特征中预示的健康隐患和注意事项
                - 提供如何通过表情、气色调整来改善面相能量的建议
            """
            
            "palm" -> """
                - 详细分析手掌的生命线、智慧线、感情线、命运线等主要线纹
                - 解读手型（水型、火型、土型、风型）对性格的影响
                - 评估指纹类型及指节特征
                - 分析大拇指、金星丘、月丘等丘陵的特点
                - 解释掌纹交叉、断裂、分叉等特殊纹路的含义
                - 结合两手掌纹的差异（先天与后天的对比）
                - 详细说明特殊标记（岛、星、格等）的命理意义
                - 提供如何强化有利掌纹能量的建议
                - 直接指出掌纹中的断裂、岛纹、交叉等不利特征的具体影响
                - 解读掌纹中预示的健康、情感或事业挑战
                - 分析手掌整体能量中的弱点和不平衡之处
                - 提供如何通过行为和习惯改变来弥补掌纹缺陷的方法
            """
            
            "fengshui" -> """
                - 基于传统风水学理论分析住宅或办公环境
                - 详细解读房屋坐向、门窗位置与五行关系
                - 分析住宅内部格局与八宅派、玄空派理论的契合度
                - 评估环境中的明堂、水口、煞气等因素
                - 解释室内装饰、颜色、材质对宅运的影响
                - 根据用户八字分析最适宜的风水布局
                - 提出具体可行的风水调整建议
                - 说明不同空间（卧室、客厅、厨房等）的风水要点
                - 指出住宅中存在的煞气、穿堂煞、冲煞等不利因素
                - 解析格局中的缺角、尖角对居住者的潜在影响
                - 评估住宅朝向与住户命理相冲的问题
                - 分析装修色彩、材质与主人五行不协调之处
                - 提供消除或化解不良风水的具体方法
            """
            
            "dream" -> """
                - 基于中国传统周公解梦和现代心理学理论
                - 详细解析梦境中的人物、事件、场景、情绪的象征意义
                - 分析梦境与做梦者现实生活的关联
                - 解读不同类型梦境（预知梦、重复梦、清醒梦等）的特殊含义
                - 结合用户生活背景与心理状态进行个性化解读
                - 从潜意识角度探讨梦境的深层次信息
                - 提供如何利用梦境指引改善现实生活的建议
                - 特别关注梦境中的关键符号和情感体验
                - 直接解读梦境中的负面元素（如死亡、坠落、追逐等）的警示意义
                - 分析梦中出现的焦虑、恐惧等情绪所反映的潜在问题
                - 指出梦境可能揭示的自我欺骗或盲点
                - 提供如何面对梦中揭示的内心冲突和不安的方法
            """
            
            "name" -> """
                - 基于传统姓名学五格剖象法进行详细分析
                - 解读天格、地格、人格、外格、总格的数理吉凶
                - 分析姓名的三才配置（天才、人才、地才）
                - 评估姓名中汉字的五行属性与用户八字的搭配
                - 解释姓名笔画数与数理能量的关系
                - 分析姓名的音律和声调对运势的影响
                - 提供姓名能量对事业、婚姻、健康等方面的影响分析
                - 如有必要，建议更为吉利的用字或改名方向
                - 直接指出姓名中的凶数、不良音律或失衡五行
                - 解析姓名与八字相冲或内部结构不协调的问题
                - 评估姓名可能对性格形成的负面影响
                - 提供根据具体情况如何选择更为平衡的用字方案
            """
            
            "zhouyi" -> """
                - 必须基于周易六十四卦和阴阳爻理论进行详细分析
                - 首先明确给出所得卦象，同时说明是上卦、下卦组合
                - 详细解读卦辞、彖辞、象辞的含义及其现代意义
                - 分析重点爻辞及其变化，解释爻位与人事的相应关系
                - 阐述卦象所反映的困境与机遇，以及适当的应对方式
                - 从五行属性和阴阳变化角度分析卦象内涵
                - 结合用户问题，针对性地解释卦象对当下形势的反映
                - 分析卦象中吉凶之象，提供趋吉避凶的实际建议
                - 解释卦象变化的趋势及其对未来发展的指引
                - 提供与卦象相关的传统智慧，引用《易经》原文加深解析
                - 直接指出卦象中的警示信息和需要注意的隐患
                - 给出符合卦象指引的行动建议和决策参考
            """
            
            else -> """
                - 提供全面、系统的分析，涵盖命理主要方面
                - 结合传统理论与现代解读，平衡古典智慧与实用性
                - 关注用户最关心的问题，提供针对性的建议
                - 包含近期运势变化与长期发展趋势的分析
                - 提供具体可行的改善建议和行动方向
                - 直接指出分析中发现的潜在风险和弱点
                - 客观评估用户面临的挑战和可能的阻碍
                - 避免过度乐观，保持客观平衡的分析态度
                - 提供实际的风险规避建议和应对策略
            """
        }
    }
    
    /**
     * 发送API请求
     */
    private fun sendRequest(context: Context, apiKey: String, prompt: String): String {
        // 创建DeepSeek API请求
        val url = URL(API_URL)
        val connection = url.openConnection() as HttpsURLConnection
        connection.requestMethod = "POST"
        connection.setRequestProperty("Content-Type", "application/json")
        connection.setRequestProperty("Authorization", "Bearer $apiKey")
        connection.doOutput = true
        
        try {
            // 构建请求体
            val requestBody = JSONObject()
            requestBody.put("model", "deepseek-chat") // 使用原始模型名称
            
            val messagesArray = JSONArray()
            val messageObject = JSONObject()
            messageObject.put("role", "user")
            messageObject.put("content", prompt)
            messagesArray.put(messageObject)
            
            requestBody.put("messages", messagesArray)
            requestBody.put("temperature", 0.7)
            requestBody.put("max_tokens", 2000)
            
            // 发送请求
            val outputStream = DataOutputStream(connection.outputStream)
            outputStream.write(requestBody.toString().toByteArray(StandardCharsets.UTF_8))
            outputStream.flush()
            outputStream.close()
            
            // 获取响应
            val responseCode = connection.responseCode
            if (responseCode == HttpURLConnection.HTTP_OK) {
                val inputStream = connection.inputStream
                val reader = BufferedReader(InputStreamReader(inputStream))
                val response = StringBuilder()
                var line: String?
                while (reader.readLine().also { line = it } != null) {
                    response.append(line)
                }
                reader.close()
                
                // 解析JSON响应
                val jsonResponse = JSONObject(response.toString())
                return jsonResponse.getJSONArray("choices")
                    .getJSONObject(0)
                    .getJSONObject("message")
                    .getString("content")
                
            } else {
                // 如果API调用失败，抛出异常
                throw Exception("API调用失败，状态码：$responseCode")
            }
        } finally {
            connection.disconnect()
        }
    }
    
    /**
     * 模拟API响应（仅在实际API调用失败时使用）
     */
    private fun simulateResponse(prompt: String): String {
        try {
        // 检查是否是占星学问题，如果是则使用专门的占星学模拟响应
        if (prompt.contains("星盘") || prompt.contains("占星") || prompt.contains("星座") || 
            prompt.contains("行星") || prompt.contains("上升") || prompt.contains("本命盘")) {
            return simulateAstrologyResponse(prompt)
        }
        
        // 检查是否是塔罗牌问题，如果是则使用专门的塔罗牌模拟响应
        if (prompt.contains("塔罗") || prompt.contains("tarot") || prompt.contains("牌阵")) {
            return simulateTarotResponse(prompt)
        }
        
        // 检查是否是解梦问题，如果是则使用专门的解梦模拟响应
        if (prompt.contains("周公解梦") || prompt.contains("解梦") || prompt.contains("梦境") || 
            prompt.contains("梦到") || prompt.contains("梦见")) {
            return simulateDreamResponse(prompt)
        }
        
        // 检查是否是周易卦象问题，如果是则使用专门的周易模拟响应
        if (prompt.contains("周易") || prompt.contains("卦象") || prompt.contains("易经") ||
                prompt.contains("六十四卦") || prompt.contains("卜卦") || prompt.contains("zhouyi")) {
                // 记录日志，便于调试
                Log.d(TAG, "检测到周易卦象问题，调用专门的模拟函数")
                val zhouYiResponse = simulateZhouYiResponse(prompt)
                
                // 检查返回内容是否为空或过短
                if (zhouYiResponse.isBlank() || zhouYiResponse.length < 100) {
                    Log.w(TAG, "周易模拟响应内容为空或过短，使用默认内容")
                    return """
                        【卦象】
                        本次预测得到乾卦。乾卦象征纯阳刚健，代表强大的创造力和领导力。
                        
                        【卦辞解析】
                        《周易》中乾卦的卦辞是："元亨利贞"。
                        
                        这个卦辞的现代解释是：象征着宏图大展、事业兴旺的征兆。建议保持坚韧不拔的态度，遵循正道，自然能获得成功。
                        
                        【情境解读】
                        针对您的问题，乾卦给出的指引是：当前局面看似复杂，但实际上正在朝着有利的方向发展。这个卦象建议您保持耐心和信心，不要被表面的困难所干扰。坚持正确的方向，最终会看到积极的结果。
                        
                        《易经》有云："天行健，君子以自强不息"，这一古老智慧在您当前的情况中尤为适用。
                        
                        【建议】
                        基于乾卦的启示，给您的具体建议是：
                        
                        1. 保持内心的平静和耐心，不要被短期的波动所干扰。
                        2. 审慎决策，避免冲动行事，确保每一步都经过深思熟虑。
                        3. 寻求值得信任的人的建议，但最终的决定应该由自己做出。
                        
                        【总结】
                        简单来说，您现在正处于充满活力和潜力的阶段，要保持坚定不移的毅力和自信心。只要按照正确的方向努力，一定能取得成功。说白了，就是坚持做对的事，不要轻易放弃，好运气自然会来敲门。
                    """
                }
                
                return zhouYiResponse
        }
        
        // 生成一个随机响应，使每次结果不同
        val currentTime = System.currentTimeMillis()
        val random = Random(currentTime)
        
        // 提取用户输入的关键信息
        val birthDateMatch = "出生日期：([^\\n]+)".toRegex().find(prompt)
        val birthTimeMatch = "出生时间：([^\\n]+)|出生时辰：([^\\n]+)".toRegex().find(prompt)
        val genderMatch = "性别：([^\\n]+)".toRegex().find(prompt)
        val questionMatch = "预测问题：([^\\n]+)|咨询问题：([^\\n]+)".toRegex().find(prompt)
        val fullNameMatch = "全名：([^\\n]+)".toRegex().find(prompt)
        
        val birthDate = birthDateMatch?.groupValues?.get(1)?.trim()
        val birthTime = birthTimeMatch?.groupValues?.get(1)?.takeIf { it.isNotEmpty() } 
            ?: birthTimeMatch?.groupValues?.get(2)?.trim()
        val gender = genderMatch?.groupValues?.get(1)?.trim()
        val question = questionMatch?.groupValues?.get(1)?.takeIf { it.isNotEmpty() } 
            ?: questionMatch?.groupValues?.get(2)?.trim()
        val fullName = fullNameMatch?.groupValues?.get(1)?.trim()
        
        val sb = StringBuilder()
        
        // 根据提示词中的关键字定制化响应
        val hasNameKeyword = prompt.contains("全名") || prompt.contains("姓名")
        val hasBirthDateKeyword = prompt.contains("出生日期") || prompt.contains("生日")
        val hasCareerKeyword = prompt.contains("事业") || prompt.contains("职业")
        val hasLoveKeyword = prompt.contains("感情") || prompt.contains("爱情") || prompt.contains("婚姻")
        
        // 生成总论部分
        sb.append("【总论】\n")
        if (fullName != null) {
            sb.append("${fullName}，")
        }
        
        if (birthDate != null) {
            sb.append("根据您${birthDate}") 
            if (birthTime != null) {
                sb.append(" ${birthTime}")
            }
            sb.append("的出生信息，")
        } else {
            sb.append("根据分析，")
        }
        
        sb.append("您的命盘显示")
        
        val traits = listOf("创造力", "领导力", "直觉", "耐心", "细心", "热情", "冷静", "理性", "感性", "随和")
        val selectedTraits = mutableListOf<String>()
        val traitCount = random.nextInt(3) + 2  // 2-4个特质
        for (i in 0 until traitCount) {
            val trait = traits[random.nextInt(traits.size)]
            if (!selectedTraits.contains(trait)) {
                selectedTraits.add(trait)
            }
        }
        sb.append("较强的${selectedTraits.joinToString("和")}。")
        
        // 添加负面特质描述
        val negativeTraits = listOf("固执", "急躁", "优柔寡断", "敏感", "多疑", "冲动", "自我中心", "过度理想化", "情绪化", "缺乏耐心")
        val selectedNegativeTraits = mutableListOf<String>()
        val negativeTraitCount = random.nextInt(2) + 1  // 1-2个负面特质
        for (i in 0 until negativeTraitCount) {
            val trait = negativeTraits[random.nextInt(negativeTraits.size)]
            if (!selectedNegativeTraits.contains(trait)) {
                selectedNegativeTraits.add(trait)
            }
        }
        sb.append("同时也存在${selectedNegativeTraits.joinToString("和")}等需要注意的性格特点。")
        
        // 随机选择五行属性
        val elements = listOf("金", "木", "水", "火", "土")
        val strongElements = elements[random.nextInt(elements.size)]
        val weakElements = elements.filter { it != strongElements }.random()
        sb.append("五行中${strongElements}较旺，${weakElements}较弱。")
        
        // 随机生成运势趋势
        val trends = listOf("稳步上升", "波动起伏", "缓慢提升", "先抑后扬", "保持平稳")
        sb.append("总体命运呈现${trends[random.nextInt(trends.size)]}的趋势，")
        
        // 随机生成关键年龄
        val age1 = random.nextInt(11) + 25  // 25-35岁
        val age2 = random.nextInt(11) + 40  // 40-50岁
        sb.append("尤其在${age1}岁和${age2}岁将有重要转折。\n\n")
        
        // 生成事业部分
        sb.append("【事业】\n")
        if (hasCareerKeyword) {
            val careerFields = listOf("管理", "教育", "艺术", "科技", "医疗", "金融", "服务", "制造", "传媒", "法律")
            val selectedFields = mutableListOf<String>()
            val fieldCount = random.nextInt(3) + 2  // 2-4个领域
            for (i in 0 until fieldCount) {
                val field = careerFields[random.nextInt(careerFields.size)]
                if (!selectedFields.contains(field)) {
                    selectedFields.add(field)
                }
            }
            sb.append("您适合从事${selectedFields.joinToString("、")}等领域的工作。")
        } else {
            sb.append("在事业发展上，")
        }
        
        val careerStages = listOf("起步", "成长", "稳定", "转型", "辉煌")
        sb.append("当前处于${careerStages[random.nextInt(careerStages.size)]}阶段，")
        
        val year1 = 2023 + random.nextInt(4)  // 2023-2026年
        val year2 = year1 + random.nextInt(3) + 1  // year1后的1-3年
        sb.append("【${year1}年到${year2}年】有重要机遇，可能带来职业上的重要突破。")
        
        val careerAdvices = listOf(
            "建议持续学习新技能，提升专业能力",
            "适合大胆创新，尝试新的领域",
            "宜稳健发展，避免冒险",
            "可以寻求合作伙伴，共同发展",
            "应该加强人脉拓展，寻求贵人相助"
        )
        sb.append(careerAdvices[random.nextInt(careerAdvices.size)] + "。\n\n")
        
        // 添加事业挑战
        val careerChallenges = listOf(
            "工作中容易因${selectedNegativeTraits.firstOrNull() ?: "急躁"}而影响决策质量",
            "事业发展可能遇到来自同行的强烈竞争",
            "工作压力较大，需注意调整心态",
            "容易被琐事分散注意力，影响效率",
            "职场人际关系需要更多耐心经营"
        )
        sb.append("需要注意的是，" + careerChallenges[random.nextInt(careerChallenges.size)] + "。\n\n")
        
        // 生成财运部分
        sb.append("【财运】\n")
        val wealthLevels = listOf("较好", "波动较大", "稳步增长", "需要谨慎规划", "潜力巨大")
        sb.append("财运整体${wealthLevels[random.nextInt(wealthLevels.size)]}，")
        
        val wealthSources = listOf("主要来自固定收入", "可通过投资获得额外收益", "有意外之财的可能", "需要勤劳积累")
        sb.append(wealthSources[random.nextInt(wealthSources.size)] + "。")
        
        val wealthYear = 2023 + random.nextInt(3)  // 2023-2025年
        sb.append("【${wealthYear}年】财运较为旺盛，")
        
        val wealthAdvices = listOf(
            "适合投资理财",
            "宜稳健理财，避免风险投资",
            "可适当进行房产投资",
            "应优先偿还债务，稳固财务基础",
            "建议增加被动收入来源"
        )
        sb.append(wealthAdvices[random.nextInt(wealthAdvices.size)] + "。\n\n")
        
        val wealthRisks = listOf(
            "投资需谨慎，近期有财务损失风险",
            "财务规划欠缺系统性，易造成资源浪费",
            "消费习惯需要调整，避免冲动消费",
            "财运虽好但守财能力较弱",
            "容易受他人影响做出不理性的财务决策"
        )
        sb.append("但也要注意，" + wealthRisks[random.nextInt(wealthRisks.size)] + "。\n\n")
        
        // 生成感情部分
        sb.append("【感情】\n")
        if (hasLoveKeyword || gender != null) {
            val loveStates = listOf(
                "感情线条清晰但曲折",
                "感情发展较为平稳",
                "感情经历波折但最终圆满",
                "需要主动追求才能获得理想感情",
                "容易吸引异性但需谨慎选择"
            )
            sb.append(loveStates[random.nextInt(loveStates.size)] + "，")
            
            val relationshipCount = random.nextInt(4) + 1  // 1-4段重要感情
            sb.append("一生中可能经历${relationshipCount}段重要感情。")
        }
        
        val loveTraits = listOf(
            "您在感情中较为理想化",
            "您在感情中注重精神交流",
            "您在感情中渴望安全感",
            "您在感情中追求刺激与新鲜感",
            "您在感情中重视忠诚与信任"
        )
        sb.append(loveTraits[random.nextInt(loveTraits.size)] + "，")
        
        val loveAdvices = listOf(
            "需要找到理解您独立精神的伴侣",
            "适合与性格互补的人建立关系",
            "应该提高沟通能力，避免误解",
            "宜放下戒备，敞开心扉接受真爱",
            "建议多关注对方需求，增进感情和谐"
        )
        sb.append(loveAdvices[random.nextInt(loveAdvices.size)] + "。\n\n")
        
        // 添加关系挑战
        val relationshipChallenges = listOf(
            "感情中易因沟通不畅导致误会",
            "对伴侣期望过高容易造成压力",
            "缺乏表达情感的能力可能影响亲密关系",
            "个人独立性与亲密关系的平衡需要调整",
            "过去的感情阴影可能影响当前关系"
        )
        sb.append("值得注意的是，" + relationshipChallenges[random.nextInt(relationshipChallenges.size)] + "。\n\n")
        
        // 生成健康部分
        sb.append("【健康】\n")
        val bodyParts = listOf("头部", "颈部", "心脏", "肺部", "胃部", "腰部", "腿部", "皮肤")
        val weakBodyPart = bodyParts[random.nextInt(bodyParts.size)]
        
        val healthStates = listOf(
            "整体健康状况良好",
            "体质较为稳定，但需加强锻炼",
            "存在一定健康隐患，需要关注",
            "体质偏弱，需要调养",
            "精力充沛，但易过度消耗"
        )
        sb.append(healthStates[random.nextInt(healthStates.size)] + "，")
        
        val healthAdvices = listOf(
            "建议加强有氧运动",
            "注意饮食均衡",
            "保持充足睡眠",
            "定期体检",
            "避免过度紧张和压力"
        )
        sb.append(healthAdvices[random.nextInt(healthAdvices.size)] + "。\n\n")
        
        val healthConcerns = listOf(
            "生活作息不规律可能导致${weakBodyPart}问题",
            "工作压力过大，注意预防精神紧张引发的身体不适",
            "饮食结构不合理可能导致营养失衡",
            "缺乏运动习惯，可能影响长期健康",
            "易忽视小症状，建议定期体检"
        )
        sb.append("值得警惕的是，" + healthConcerns[random.nextInt(healthConcerns.size)] + "。\n\n")
        
        // 生成建议部分
        sb.append("【建议】\n")
        
        // 如果有具体问题，添加针对性建议
        if (question != null) {
            sb.append("关于\"${question}\"的问题，")
            val specificAdvices = listOf(
                "建议您保持耐心，时机尚未成熟",
                "目前情况对您有利，可以积极行动",
                "需要谨慎考虑各方面因素，不宜操之过急",
                "有贵人相助的迹象，可以寻求他人支持",
                "时机已到，可以果断决策"
            )
            sb.append(specificAdvices[random.nextInt(specificAdvices.size)] + "。\n\n")
        }
        
        val adviceCount = random.nextInt(3) + 4  // 4-6条建议
        val allAdvices = listOf(
            "培养耐心和持续力，不要因短期困难放弃长远目标",
            "加强情绪管理，避免冲动决策",
            "建立健康的生活习惯，包括饮食、运动和休息",
            "学习财务规划，合理配置资产",
            "在人际关系中保持真诚，但也要有适当边界",
            "定期反思与调整，使人生方向与内心期望一致",
            "多与积极向上的人交往，远离负能量",
            "培养一项终身爱好，丰富精神世界",
            "学会感恩，保持积极乐观的心态",
            "关注精神成长，提升内在修养"
        )
        
        val selectedAdvices = allAdvices.shuffled().take(adviceCount)
        for (i in selectedAdvices.indices) {
            sb.append("${i + 1}. ${selectedAdvices[i]}")
            // 确保每条建议后都有换行
            if (i < selectedAdvices.size - 1) {
                sb.append("\n")
            }
        }
        
        return sb.toString()
        } catch (e: Exception) {
            Log.e(TAG, "生成模拟响应时出错", e)
            return """
                【模拟响应】
                生成模拟响应时出现错误。
                
                【原因】
                可能是由于输入格式不正确或系统临时故障。
                
                【建议】
                1. 请重新尝试算命
                2. 如果问题持续，可以尝试使用其他算命方式
                3. 确保输入的问题清晰明确
                
                【总结】
                简单说，系统现在遇到了点小问题，建议您稍后再试，或者换个算命方式。
            """
        }
    }
    
    /**
     * 模拟占星学响应（专门为占星学方法设计）
     */
    private fun simulateAstrologyResponse(prompt: String): String {
        // 使用固定的种子使每次结果不同但可预测
        val currentTime = System.currentTimeMillis()
        val random = Random(currentTime)
        
        // 提取用户输入的关键信息
        val birthDateMatch = "出生日期：([^\\n]+)".toRegex().find(prompt)
        val birthTimeMatch = "出生时间：([^\\n]+)|出生时辰：([^\\n]+)".toRegex().find(prompt)
        val genderMatch = "性别：([^\\n]+)".toRegex().find(prompt)
        val questionMatch = "预测问题：([^\\n]+)|咨询问题：([^\\n]+)".toRegex().find(prompt)
        val fullNameMatch = "全名：([^\\n]+)".toRegex().find(prompt)
        
        val birthDate = birthDateMatch?.groupValues?.get(1)?.trim()
        val birthTime = birthTimeMatch?.groupValues?.get(1)?.takeIf { it.isNotEmpty() } 
            ?: birthTimeMatch?.groupValues?.get(2)?.trim()
        val gender = genderMatch?.groupValues?.get(1)?.trim()
        val question = questionMatch?.groupValues?.get(1)?.takeIf { it.isNotEmpty() } 
            ?: questionMatch?.groupValues?.get(2)?.trim()
        val fullName = fullNameMatch?.groupValues?.get(1)?.trim()
        
        val sb = StringBuilder()
        
        // 生成星盘描述数据（这部分将被提取到星盘视图中）
        sb.append("【星盘描述】\n")
        
        // 添加行星位置信息
        sb.append("行星位置：\n")
        
        val planets = listOf("太阳", "月亮", "水星", "金星", "火星", "木星", "土星", "天王星", "海王星", "冥王星", "上升点", "中天点")
        val zodiacSigns = listOf("白羊", "金牛", "双子", "巨蟹", "狮子", "处女", "天秤", "天蝎", "射手", "摩羯", "水瓶", "双鱼")
        
        // 为每个行星生成随机星座和度数
        for (planet in planets) {
            val zodiac = zodiacSigns[random.nextInt(zodiacSigns.size)]
            val degree = random.nextInt(30)
            sb.append("* ${planet}位于${zodiac}座${degree}度\n")
        }
        
        // 添加行星相位信息
        sb.append("\n行星相位：\n")
        
        // 生成几个随机相位关系
        val aspectTypes = listOf("三分相", "六分相", "四分相", "对分相", "合相")
        val aspectCount = 5 + random.nextInt(3)  // 5-7个相位
        
        val selectedPairs = mutableSetOf<Pair<String, String>>()
        for (i in 0 until aspectCount) {
            var planet1 = planets[random.nextInt(planets.size - 2)]
            var planet2 = planets[random.nextInt(planets.size - 2)]
            
            // 确保不重复且不与自己形成相位
            var pair = Pair(planet1, planet2)
            while (planet1 == planet2 || selectedPairs.contains(pair) || selectedPairs.contains(Pair(planet2, planet1))) {
                planet1 = planets[random.nextInt(planets.size - 2)]
                planet2 = planets[random.nextInt(planets.size - 2)]
                pair = Pair(planet1, planet2)
            }
            selectedPairs.add(pair)
            
            val aspectType = aspectTypes[random.nextInt(aspectTypes.size)]
            val degree = when (aspectType) {
                "三分相" -> 120
                "六分相" -> 60
                "四分相" -> 90
                "对分相" -> 180
                "合相" -> 0
                else -> 0
            }
            
            // 添加一点随机偏差
            val deviation = random.nextInt(5)
            val finalDegree = degree + deviation
            
            sb.append("* ${planet1}和${planet2}形成${aspectType}(${finalDegree}度)\n")
        }
        
        // 添加总论部分
        sb.append("\n【总论】\n")
        if (fullName != null) {
            sb.append("${fullName}，")
        }
        
        if (birthDate != null) {
            sb.append("根据您${birthDate}")
            if (birthTime != null) {
                sb.append(" ${birthTime}")
            }
            sb.append("的出生数据，")
        }
        
        sb.append("您的星盘显示：")
        
        // 随机选择主宫位
        val houses = listOf("第一宫(上升宫)", "第四宫(天底宫)", "第七宫(下降宫)", "第十宫(中天宫)")
        val selectedHouse = houses[random.nextInt(houses.size)]
        
        // 随机选择强势星座
        val strongZodiac = zodiacSigns[random.nextInt(zodiacSigns.size)]
        
        sb.append("在您的星盘中，${selectedHouse}位于${strongZodiac}座，")
        
        // 随机选择一个行星作为主导
        val leadingPlanet = planets[random.nextInt(planets.size - 2)]  // 排除上升点和中天点
        sb.append("${leadingPlanet}是您星盘的主导行星，")
        
        // 添加一些性格特质描述
        val traits = listOf("创造力", "逻辑思维", "情感敏感度", "行动力", "沟通能力", "直觉", "稳定性", "变通性")
        val selectedTraits = mutableListOf<String>()
        val traitCount = 2 + random.nextInt(2)  // 2-3个特质
        
        for (i in 0 until traitCount) {
            val trait = traits[random.nextInt(traits.size)]
            if (!selectedTraits.contains(trait)) {
                selectedTraits.add(trait)
            }
        }
        
        sb.append("这表明您的${selectedTraits.joinToString("和")}较为突出。\n\n")
        
        // 生成十二宫解读
        val houseThemes = mapOf(
            "第一宫" to "自我形象和外在表现",
            "第二宫" to "个人财产和价值观",
            "第三宫" to "沟通、思维和短途旅行",
            "第四宫" to "家庭、根基和内心情感",
            "第五宫" to "创造力、爱情和娱乐",
            "第六宫" to "日常工作、健康和服务",
            "第七宫" to "伴侣关系和合作",
            "第八宫" to "共享资源、转变和神秘",
            "第九宫" to "高等教育、哲学和远程旅行",
            "第十宫" to "职业、社会地位和成就",
            "第十一宫" to "朋友、团体和愿望",
            "第十二宫" to "潜意识、秘密和精神世界"
        )
        
        // 随机选择几个宫位进行解读
        val houseKeys = houseThemes.keys.toList()
        val selectedHouses = houseKeys.shuffled(random).take(3)
        
        for (house in selectedHouses) {
            val theme = houseThemes[house]
            val zodiac = zodiacSigns[random.nextInt(zodiacSigns.size)]
            val planet = planets[random.nextInt(planets.size - 2)]
            
            sb.append("【${house}解读】\n")
            sb.append("您的${house}位于${zodiac}座，受到${planet}的影响。这个宫位代表${theme}。")
            
            val positiveEffects = listOf(
                "这暗示着您在该领域有较强的天赋",
                "这为您带来了积极的能量和机会",
                "这赋予您独特的视角和能力",
                "这使您能够以创造性的方式处理相关问题",
                "这使您在该领域更容易取得成功"
            )
            
            val challenges = listOf(
                "不过，这也可能带来一些挑战，如过度关注细节",
                "然而，您可能需要克服对完美的追求",
                "您需要注意平衡理性和情感的需求",
                "有时可能导致您对自己要求过高",
                "偶尔可能会让您感到压力过大"
            )
            
            sb.append(positiveEffects[random.nextInt(positiveEffects.size)] + "。")
            sb.append(challenges[random.nextInt(challenges.size)] + "。\n\n")
        }
        
        // 添加事业部分
        sb.append("【事业】\n")
        val careerPlanets = listOf("太阳", "土星", "木星", "火星", "水星")
        val careerPlanet = careerPlanets[random.nextInt(careerPlanets.size)]
        
        sb.append("您的事业宫受到${careerPlanet}的主要影响，")
        
        val careerAreas = listOf(
            "创意领域", "科技行业", "财务金融", "医疗健康", 
            "教育培训", "咨询服务", "公共关系", "研究分析"
        )
        
        val selectedAreas = careerAreas.shuffled(random).take(2)
        sb.append("适合从事${selectedAreas.joinToString("或")}。")
        
        // 添加事业周期
        val currentYear = java.util.Calendar.getInstance().get(java.util.Calendar.YEAR)
        val nextYear = currentYear + 1
        val futureYear = currentYear + 2 + random.nextInt(3)
        
        sb.append("从${currentYear}年到${nextYear}年是事业转型期，")
        sb.append("而${futureYear}年将是您事业的重要突破点。\n\n")
        
        // 添加感情部分
        sb.append("【感情】\n")
        val lovePlanets = listOf("金星", "火星", "月亮", "木星")
        val lovePlanet = lovePlanets[random.nextInt(lovePlanets.size)]
        
        sb.append("在感情方面，您的星盘显示${lovePlanet}对您的影响较大，")
        
        val loveTraits = listOf(
            "这意味着您注重关系中的稳定和安全",
            "这表明您在关系中非常重视沟通和理解",
            "这意味着您往往以情感和直觉指导关系",
            "这暗示您在感情中寻求自由和独立",
            "这表明您对伴侣有较高的标准和期望"
        )
        
        sb.append(loveTraits[random.nextInt(loveTraits.size)] + "。")
        
        // 感情状态预测
        val loveYear = currentYear + random.nextInt(2)
        sb.append("${loveYear}年对您的感情生活有特殊意义，可能会有重要的关系转变或进展。\n\n")
        
        // 添加健康部分
        sb.append("【健康】\n")
        
        // 随机选择几个可能的健康注意事项
        val healthConcerns = listOf(
            "注意消化系统健康",
            "关注心血管健康",
            "保持呼吸系统健康",
            "重视情绪压力管理",
            "留意睡眠质量",
            "关注关节健康",
            "维护免疫系统功能"
        )
        
        val selectedConcerns = healthConcerns.shuffled(random).take(2)
        
        sb.append("星盘显示您应该特别${selectedConcerns.joinToString("，并且")}。")
        
        // 添加一些健康建议
        val healthAdvice = listOf(
            "规律的体育活动对您尤为重要",
            "均衡饮食有助于维持您的能量水平",
            "定期休息和充足睡眠对您至关重要",
            "冥想和放松技巧可以帮助您保持平衡",
            "定期体检是保持健康的关键"
        )
        
        sb.append(healthAdvice[random.nextInt(healthAdvice.size)] + "。\n\n")
        
        // 添加建议部分
        sb.append("【建议】\n")
        
        // 如果有具体问题，添加针对性建议
        if (question != null) {
            sb.append("关于\"${question}\"的问题，根据您的星盘分析：\n")
            
            val specificAdvices = listOf(
                "目前星象对您有利，可以积极行动",
                "需要等待更有利的星象对齐，建议保持耐心",
                "本阶段应专注于收集信息和规划，暂缓重大决策",
                "星盘显示这是一个转变期，适合做出改变",
                "当前星相表明，这个问题的解决需要您更全面的考虑"
            )
            
            sb.append(specificAdvices[random.nextInt(specificAdvices.size)] + "。\n\n")
        }
        
        // 添加一般性建议
        val generalAdvices = listOf(
            "利用您的${selectedTraits.firstOrNull() ?: "创造力"}优势，发挥潜能",
            "注意观察天象变化对您情绪的影响",
            "寻找平衡各个生活领域的方法",
            "重视自我反思和内在成长",
            "关注星象周期变化，把握有利时机",
            "记录星象变化与个人体验，增进自我了解",
            "尝试与您星座相合的活动和环境",
            "培养与您主导行星能量协调的习惯"
        )
        
        // 添加3-5条建议
        val adviceCount = 3 + random.nextInt(3)
        val selectedAdvices = generalAdvices.shuffled(random).take(adviceCount)
        
        for (i in selectedAdvices.indices) {
            sb.append("${i + 1}. ${selectedAdvices[i]}")
            if (i < selectedAdvices.size - 1) {
                sb.append("\n")
            }
        }
        
        return sb.toString()
    }
    
    /**
     * 模拟塔罗牌响应（专门为塔罗牌方法设计）
     */
    private fun simulateTarotResponse(prompt: String): String {
        // 使用固定的种子使每次结果不同但可预测
        val currentTime = System.currentTimeMillis()
        val random = Random(currentTime)
        
        // 提取用户输入的关键信息
        val questionMatch = "预测问题：([^\\n]+)|咨询问题：([^\\n]+)".toRegex().find(prompt)
        val fullNameMatch = "全名：([^\\n]+)".toRegex().find(prompt)
        
        val question = questionMatch?.groupValues?.get(1)?.takeIf { it.isNotEmpty() } 
            ?: questionMatch?.groupValues?.get(2)?.trim()
        val fullName = fullNameMatch?.groupValues?.get(1)?.trim()
        
        val sb = StringBuilder()
        
        // 生成牌阵概述
        sb.append("【概览】\n")
        
        if (fullName != null) {
            sb.append("${fullName}，")
        }
        
        if (question != null) {
            sb.append("关于\"${question}\"的问题，")
        } else {
            sb.append("根据您的提问，")
        }
        
        // 随机选择牌阵类型
        val spreadTypes = listOf("三张牌展开", "凯尔特十字牌阵", "过去-现在-未来牌阵", "五张牌展开", "关系牌阵")
        val spreadType = spreadTypes[random.nextInt(spreadTypes.size)]
        
        sb.append("我为您进行了${spreadType}塔罗牌分析。")
        
        val cardCount = when (spreadType) {
            "三张牌展开", "过去-现在-未来牌阵" -> 3
            "五张牌展开" -> 5
            "凯尔特十字牌阵" -> 10
            "关系牌阵" -> 6
            else -> 3
        }
        
        // 塔罗牌名称列表
        val majorArcana = listOf(
            "愚者", "魔术师", "女祭司", "女皇", "皇帝", "教皇", "恋人", "战车", 
            "力量", "隐士", "命运之轮", "正义", "倒吊人", "死神", "节制", 
            "恶魔", "塔", "星星", "月亮", "太阳", "审判", "世界"
        )
        
        val minorSuits = listOf("圣杯", "星币", "宝剑", "权杖")
        val minorRanks = listOf("Ace", "二", "三", "四", "五", "六", "七", "八", "九", "十", "侍从", "骑士", "王后", "国王")
        
        val allCards = mutableListOf<String>()
        allCards.addAll(majorArcana)
        
        for (suit in minorSuits) {
            for (rank in minorRanks) {
                allCards.add("$suit$rank")
            }
        }
        
        // 选择不重复的牌
        val selectedCards = allCards.shuffled(random).take(cardCount)
        val cardPositions = listOf("正位", "逆位")
        
        sb.append("本次抽取的牌为：")
        for (i in 0 until cardCount) {
            val position = cardPositions[random.nextInt(2)]
            sb.append("\n${i + 1}. ${selectedCards[i]}（${position}）")
        }
        sb.append("\n\n")
        
        // 生成牌面解读
        sb.append("【牌面解读】\n")
        
        // 根据牌阵类型生成不同的位置标题
        val positionTitles = when (spreadType) {
            "过去-现在-未来牌阵" -> listOf("过去", "现在", "未来")
            "凯尔特十字牌阵" -> listOf("核心问题", "障碍", "潜意识", "过去", "现状", "未来", "自我态度", "环境影响", "希望或恐惧", "最终结果")
            "关系牌阵" -> listOf("您自己", "对方", "关系现状", "关系基础", "过去影响", "未来发展")
            else -> (1..cardCount).map { "第${it}张牌" }
        }
        
        for (i in 0 until cardCount) {
            if (i < positionTitles.size) {
                sb.append("${positionTitles[i]}：${selectedCards[i]}\n")
            } else {
                sb.append("位置${i + 1}：${selectedCards[i]}\n")
            }
            
            // 生成牌面解释
            val meanings = listOf(
                "象征着内在的力量与潜能",
                "代表着变革与转机",
                "显示出挑战与机遇并存",
                "暗示着需要放下过去，迎接新的开始",
                "建议保持耐心与坚持",
                "提醒注意内心的真实需求",
                "表明当前处于选择的关键时刻",
                "体现了成长与进步的可能",
                "昭示着即将到来的变化"
            )
            
            sb.append("${meanings[random.nextInt(meanings.size)]}。")
            
            // 为每个牌添加一些细节解读
            val details = listOf(
                "牌面中的${listOf("光明", "黑暗", "水流", "山脉", "天空", "大地").random()}元素，暗示着${listOf("希望", "挑战", "流动性", "稳定性", "开阔视野", "根基").random()}。",
                "牌中人物的${listOf("姿态", "表情", "服饰", "手势").random()}透露出${listOf("内在力量", "犹豫不决", "自信满满", "深思熟虑").random()}的状态。",
                "牌的${listOf("色彩", "构图", "象征物").random()}与您的问题形成有趣的呼应。"
            )
            
            sb.append("${details[random.nextInt(details.size)]}\n\n")
        }
        
        // 生成综合分析
        sb.append("【深度分析】\n")
        
        // 根据所选牌的组合生成综合分析
        val hasPositiveCards = selectedCards.any { it in listOf("魔术师", "太阳", "星星", "世界", "力量", "女皇", "正义") }
        val hasNegativeCards = selectedCards.any { it in listOf("死神", "塔", "恶魔", "月亮", "倒吊人") }
        val hasNeutralCards = selectedCards.any { it in listOf("隐士", "命运之轮", "审判", "节制", "教皇") }
        
        if (hasPositiveCards && !hasNegativeCards) {
            sb.append("整体牌面呈现积极向上的能量。")
        } else if (hasNegativeCards && !hasPositiveCards) {
            sb.append("牌面显示当前您可能面临一些挑战。")
        } else {
            sb.append("牌面展示了复杂而多元的能量场域。")
        }
        
        // 添加更多综合分析
        val analysisPoints = listOf(
            "从整体牌阵的能量分布来看，${listOf("水元素", "火元素", "土元素", "风元素").random()}的强势表明您在${listOf("情感", "行动", "实务", "思考").random()}方面有特殊的优势。",
            
            "值得注意的是，牌阵中${if (random.nextBoolean()) "大阿尔卡纳" else "小阿尔卡纳"}牌的比例较高，这通常意味着${
                listOf(
                    "命运力量正在发挥主导作用", 
                    "您自身的选择将影响结果", 
                    "外部环境因素影响显著", 
                    "您处于生命的重要转折点"
                ).random()
            }。",
            
            "牌阵中的${selectedCards[random.nextInt(cardCount)]}与${selectedCards[random.nextInt(cardCount)]}形成有趣的互动，这可能提示${
                listOf(
                    "内在冲突需要调和", 
                    "矛盾的力量将带来创造性突破", 
                    "不同领域的经验可以相互借鉴", 
                    "当前的选择将影响多个生活方面"
                ).random()
            }。"
        )
        
        // 添加2-3点分析
        val analysisCount = 2 + random.nextInt(2)
        for (i in 0 until analysisCount) {
            sb.append("\n\n${analysisPoints[i % analysisPoints.size]}")
        }
        
        sb.append("\n\n")
        
        // 生成建议
        sb.append("【建议】\n")
        
        // 根据牌面情况给出建议
        val adviceCount = 3 + random.nextInt(2) // 3-4条建议
        val advices = listOf(
            "留意内心的直觉，它往往比逻辑思考更能引领您找到答案。",
            "现在是审视自身价值观和优先事项的好时机。",
            "保持开放心态，接纳变化带来的新可能性。",
            "与信任的人分享您的想法，外部视角可能带来意想不到的启示。",
            "适当的休息和反思将帮助您找到正确的方向。",
            "注意力集中在您能够控制的事物上，放下对不确定因素的担忧。",
            "信任时间的力量，一些事情需要自然发展。",
            "勇敢面对挑战，每个困难都蕴含成长的机会。",
            "重视细节，但不要忘记全局视角。",
            "寻找平衡点，避免走向任何极端。"
        )
        
        // 如果有特定问题，添加一条针对性建议
        if (question != null) {
            val specificAdvices = listOf(
                "关于\"${question}\"，牌面显示此时最好${if (random.nextBoolean()) "保持耐心" else "果断行动"}。",
                "在\"${question}\"这个问题上，塔罗提示您可能需要重新审视自己的${if (random.nextBoolean()) "期望" else "方法"}。",
                "对于\"${question}\"，牌面建议您寻求${if (random.nextBoolean()) "平衡与和谐" else "突破与创新"}。"
            )
            sb.append("${specificAdvices[random.nextInt(specificAdvices.size)]}\n\n")
        }
        
        // 添加一般性建议
        val selectedAdvices = advices.shuffled(random).take(adviceCount)
        for (i in selectedAdvices.indices) {
            sb.append("${i + 1}. ${selectedAdvices[i]}")
            if (i < selectedAdvices.size - 1) {
                sb.append("\n")
            }
        }
        
        return sb.toString()
    }
    
    /**
     * 模拟周公解梦响应（专门为解梦方法设计）
     */
    private fun simulateDreamResponse(prompt: String): String {
        // 使用固定的种子使每次结果不同但可预测
        val currentTime = System.currentTimeMillis()
        val random = Random(currentTime)
        
        // 提取用户输入的关键信息
        val dreamContentMatch = "梦境内容：([^\\n]+)|梦见：([^\\n]+)|梦到：([^\\n]+)".toRegex().find(prompt)
        val fullNameMatch = "全名：([^\\n]+)".toRegex().find(prompt)
        
        val dreamContent = dreamContentMatch?.groupValues?.let { 
            it[1].takeIf { it.isNotEmpty() } ?: it[2].takeIf { it.isNotEmpty() } ?: it[3].takeIf { it.isNotEmpty() }
        }?.trim()
        
        val fullName = fullNameMatch?.groupValues?.get(1)?.trim()
        
        // 尝试从提示词中提取更多梦境信息
        val promptLowerCase = prompt.lowercase()
        val commonDreams = listOf(
            "飞", "坠落", "追逐", "考试", "迟到", "裸体", "死亡", "失去牙齿", "怀孕", "蛇", 
            "水", "火", "动物", "亲人", "钱", "房子", "车", "婚礼", "工作", "旅行",
            "鬼", "怪物", "名人", "前任", "陌生人", "食物", "学校", "医院", "战争"
        )
        
        // 尝试识别梦境类型
        var detectedDream = ""
        for (dream in commonDreams) {
            if (promptLowerCase.contains("梦见$dream") || 
                promptLowerCase.contains("梦到$dream") || 
                promptLowerCase.contains("梦中$dream") ||
                promptLowerCase.contains("梦境中$dream")) {
                detectedDream = dream
                break
            }
        }
        
        // 如果没有提取到明确的梦境内容，但发现了常见梦境关键词
        val effectiveDreamContent = dreamContent ?: if (detectedDream.isNotEmpty()) {
            "梦见$detectedDream"
        } else {
            "梦境内容不明确"
        }
        
        val sb = StringBuilder()
        
        // 生成梦境概述部分
        sb.append("【梦境概述】\n")
        
        if (fullName != null) {
            sb.append("${fullName}，")
        }
        
        if (effectiveDreamContent != "梦境内容不明确") {
            sb.append("关于您「${effectiveDreamContent}」的梦境，")
        } else {
            sb.append("关于您所描述的梦境，")
        }
        
        // 梦境类型
        val dreamTypes = listOf("预示梦", "反映梦", "创造性梦境", "日常反射梦", "潜意识表达梦", "清醒梦", "重复梦")
        val selectedDreamType = dreamTypes[random.nextInt(dreamTypes.size)]
        
        sb.append("这是一种典型的${selectedDreamType}。")
        
        // 添加梦境形成原因
        val dreamCauses = listOf(
            "这类梦境通常源于您近期的心理状态和情绪变化",
            "这种梦可能反映了您潜意识中的某些担忧或期待",
            "这一梦境可能是由您最近的经历或周围环境变化引起的",
            "这种梦境往往与您内心的欲望或恐惧有关",
            "这类梦境通常是大脑整合记忆和处理情绪的方式"
        )
        
        sb.append(dreamCauses[random.nextInt(dreamCauses.size)] + "。\n\n")
        
        // 添加传统解梦部分
        sb.append("【传统解读】\n")
        
        // 根据不同梦境内容提供不同解读
        val traditionalInterpretations = mapOf(
            "飞" to "梦见飞翔通常象征着自由、超越和成功的渴望。在传统周公解梦中，这被视为吉兆，预示着事业上会有提升或突破。",
            "坠落" to "梦见坠落反映了不安全感和对失控的恐惧。传统解梦认为，这可能预示着近期会遇到一些挑战，需要更加谨慎地处理事务。",
            "追逐" to "被追逐的梦境通常代表着逃避某种压力或责任。古籍中认为，这种梦可能暗示您需要面对而非逃避当前的问题。",
            "考试" to "考试梦反映了对评判和失败的焦虑。传统解梦认为，这预示着近期可能面临重要选择或考验，需要充分准备。",
            "迟到" to "梦见迟到通常表示对错失机会的担忧。周公解梦认为这提醒您把握当前机遇，不要拖延重要事项。",
            "裸体" to "裸体梦通常反映脆弱感或对暴露真实自我的恐惧。传统解释认为这可能暗示您在某些社交场合感到不自在或不安全。",
            "死亡" to "死亡梦象征着结束和新生。在传统解梦中，这通常不是不祥之兆，而是代表一个阶段的结束和新阶段的开始。",
            "失去牙齿" to "梦见牙齿掉落在传统解梦中与家人健康和沟通有关。这可能反映了对失去能力或控制的恐惧。",
            "怀孕" to "怀孕梦象征着新想法、项目或关系的发展。传统上认为这是创造力和新开始的预兆。",
            "蛇" to "梦见蛇在传统解梦中有双重含义，可代表智慧和转变，也可能象征潜在的威胁或欺骗。具体解释需结合梦境细节。",
            "水" to "水的梦境与情感状态密切相关。清澈平静的水代表内心平和，而湍急或浑浊的水则暗示情绪波动或不安。",
            "火" to "火象征转变、净化或激情。在周公解梦中，梦见火可能预示生活中的重大变化或情感上的强烈体验。",
            "动物" to "动物梦通常反映我们的本能和特质。不同动物有不同象征，传统解梦认为这与您内在品质或当前面临的情况有关。",
            "亲人" to "梦见亲人通常反映您与他们的关系状态或对他们的思念。传统上认为，已故亲人出现在梦中可能是在传递信息或提供指引。",
            "钱" to "梦见钱财在传统解释中通常与机遇和资源有关。赚钱预示好运，而丢钱则可能暗示需要注意资源管理。",
            "房子" to "房子在梦中代表自我和安全感。传统解梦认为，不同状态的房子反映了您对自身生活空间和安全感的认知。",
            "车" to "车辆象征人生旅程和控制感。传统解释认为，梦见驾车反映了您如何掌控自己的人生方向。",
            "婚礼" to "婚礼梦不仅与爱情有关，也代表着人生中的承诺和转变。在传统解梦中，这通常被视为新阶段开始的象征。",
            "工作" to "工作相关的梦通常反映职业压力或成就感。传统解释认为，这类梦境反映了您的职业抱负和担忧。",
            "旅行" to "旅行梦象征人生旅程和探索。在周公解梦中，这通常被视为积极的变化和新机遇的征兆。",
            "鬼" to "梦见鬼怪在传统解梦中通常与未解决的恐惧或过去的问题有关。这提醒您可能需要面对过去或内心的阴暗面。",
            "怪物" to "怪物象征内心的恐惧或被压抑的情绪。传统解释认为，这类梦境提醒您需要勇敢面对困难和挑战。",
            "名人" to "梦见名人可能反映您对某些品质或成就的向往。传统解梦认为，这与您的抱负或自我认同有关。",
            "前任" to "前任出现在梦中通常与未解决的感情或过去的经验有关。这可能暗示您需要释放过去，才能更好地前行。",
            "陌生人" to "陌生人在梦中常代表自我的未知面向或新的可能性。传统解释认为，这可能预示着新关系或机会的到来。",
            "食物" to "食物梦与滋养和满足需求有关。传统解梦认为，不同的食物象征不同的精神或情感需求。",
            "学校" to "学校梦常反映对表现和评价的焦虑。传统上认为，这类梦境提醒您重视学习和个人成长。",
            "医院" to "医院梦境与健康忧虑或疗愈需求有关。传统解释认为，这提醒注意身心健康，或暗示需要休息和调养。",
            "战争" to "战争梦象征内心或外部的冲突。在传统解梦中，这类梦境反映了内心的矛盾或人际关系中的紧张。"
        )
        
        var interpretationProvided = false
        
        // 如果能识别特定梦境元素，提供相应解读
        if (detectedDream.isNotEmpty() && traditionalInterpretations.containsKey(detectedDream)) {
            sb.append(traditionalInterpretations[detectedDream] ?: "")
            interpretationProvided = true
        } else if (dreamContent != null) {
            // 尝试从梦境内容中识别关键词
            for ((keyword, interpretation) in traditionalInterpretations) {
                if (dreamContent.contains(keyword)) {
                    sb.append(interpretation)
                    interpretationProvided = true
                    break
                }
            }
        }
        
        // 如果没有找到特定解读，提供通用解读
        if (!interpretationProvided) {
            val generalInterpretations = listOf(
                "根据周公解梦的传统理论，您的梦境反映了潜意识中的变化与调整。梦中的情景和情绪是现实生活的投射，提示您关注内心需求。",
                "传统解梦学认为，这类梦境常与人生转变期有关，象征着旧阶段的结束和新阶段的开始。梦中的象征元素反映了您对这一转变的感受。",
                "周公解梦中认为，此类梦境通常与内心渴望或隐忧有关。梦境通过象征性图像表达了您可能尚未完全意识到的感受。",
                "古籍中解释，这种梦境往往是大脑整合记忆和处理情绪的自然过程。梦中出现的场景和人物可能是过去经历的重组。"
            )
            
            sb.append(generalInterpretations[random.nextInt(generalInterpretations.size)])
        }
        
        // 添加传统吉凶判断
        val fortunes = listOf("吉", "中吉", "小吉", "凶中带吉", "吉中有凶", "小凶", "大凶")
        var fortuneWeight = listOf(3, 2, 2, 1, 1, 1, 0)  // 权重倾向于吉利的结果
        
        // 如果梦到一些特别内容，调整权重
        if (detectedDream in listOf("死亡", "坠落", "追逐", "鬼", "战争")) {
            fortuneWeight = listOf(1, 1, 2, 2, 2, 1, 1)  // 更平衡的权重
        }
        
        var fortune = ""
        val fortuneRoll = random.nextInt(fortuneWeight.sum())
        var accumulatedWeight = 0
        
        for (i in fortunes.indices) {
            accumulatedWeight += fortuneWeight[i]
            if (fortuneRoll < accumulatedWeight) {
                fortune = fortunes[i]
                break
            }
        }
        
        sb.append("\n\n根据周公解梦古籍记载，此梦「${fortune}」。\n\n")
        
        // 添加心理学解读部分
        sb.append("【现代解析】\n")
        
        val psychologicalInterpretations = listOf(
            "从现代心理学角度看，这类梦境常反映潜意识中的情绪处理过程。弗洛伊德认为，梦是被压抑欲望的表达；而荣格则视梦为通往集体无意识的窗口。",
            "现代梦境分析认为，梦是大脑处理和整合日常经历的方式。您的梦可能是在帮助您处理最近经历的事件或情绪变化。",
            "心理学家解释，这种梦境类型通常与自我认同和成长有关。梦境内容反映了您内心正在发生的变化和调整过程。",
            "当代研究表明，此类梦境常与压力和情绪调节相关。梦可能是您处理压力或适应变化的一种方式。",
            "从神经科学角度看，这种梦境模式可能与记忆巩固和情绪处理有关。大脑在梦中重新组织和整合经验，形成新的认知联系。"
        )
        
        sb.append(psychologicalInterpretations[random.nextInt(psychologicalInterpretations.size)] + " ")
        
        // 添加个人情境相关解析
        val personalContexts = listOf(
            "您的梦境可能反映了当前生活中的某些变化或挑战。思考一下，梦中的元素如何与您的现实经历相呼应？",
            "这个梦可能是提醒您关注被忽视的情感或需求。梦中的象征常常代表我们在清醒状态下容易忽略的思绪。",
            "您的梦境可能在提示您重新评估某些关系或生活方向。梦中出现的人物和情境可能象征着现实中需要关注的方面。",
            "这类梦常与自我成长和转变有关。思考梦中的挑战可能代表您人生旅程中的哪些成长机会？",
            "您的梦可能是在处理未解决的情感或冲突。梦境提供了一个安全的空间，使潜意识能够探索和处理复杂感受。"
        )
        
        sb.append(personalContexts[random.nextInt(personalContexts.size)] + "\n\n")
        
        // 添加建议部分
        sb.append("【启示与建议】\n")
        
        // 根据梦境内容提供针对性建议
        var adviceProvided = false
        
        val dreamAdvices = mapOf(
            "飞" to "这个梦鼓励您释放创造力，追求自由和突破界限。在现实生活中，可以尝试拓展舒适区，探索新的可能性。",
            "坠落" to "这个梦提醒您关注生活中的稳定和安全感。建议审视当前压力来源，建立更坚实的支持系统，适当放慢步伐，确保自己站稳脚跟。",
            "追逐" to "这个梦境鼓励您直面而非逃避挑战。建议列出当前困扰您的问题，制定具体应对计划，必要时寻求支持，转被动为主动。",
            "考试" to "这类梦境建议您正视对评判的焦虑。可以通过充分准备、设定合理期望、学习接受不完美来缓解压力，记住，成长比完美更重要。",
            "迟到" to "这个梦提醒您关注时间管理和对重要事项的规划。建议评估当前优先级，制定更合理的时间表，避免拖延重要决定。",
            "裸体" to "这个梦鼓励您接纳真实的自己，建议反思在哪些场合或关系中感到脆弱，学习在保持真实的同时建立健康界限。",
            "死亡" to "这个梦象征转变和新生，鼓励您接纳生活的变化。建议反思哪些方面需要结束，哪些新的可能性正在开启，允许自己告别过去，拥抱未来。",
            "失去牙齿" to "这类梦境通常与沟通和表达有关。建议关注人际交往中的沟通方式，确保有效表达自己的观点和需求，同时保持适当自信。",
            "怀孕" to "这个梦鼓励您关注正在发展的新想法或项目。给自己足够的时间和空间来培育这些'种子'，相信创造过程，耐心等待成果。",
            "蛇" to "蛇的梦境提示您关注转变和智慧。建议思考生活中哪些方面需要蜕变，警惕潜在的欺骗或隐患，同时拥抱自我更新的过程。",
            "水" to "水的梦境建议您关注情绪健康。可以通过冥想、写日记或与信任的人分享感受来探索和处理情绪，让情感如水般流动而不淤积。",
            "火" to "火的梦境鼓励您拥抱变化和净化。审视哪些过时的思维模式或习惯需要放下，允许激情引导您，但注意控制其强度，避免'燃尽'。",
            "动物" to "动物梦鼓励您关注本能和直觉。反思梦中动物代表的品质在您生活中如何体现，学习平衡理性思考和直觉反应。",
            "亲人" to "这类梦境提醒您关注家庭关系。可以主动联系亲人，表达关爱，解决可能存在的隔阂，珍视这些重要联系。",
            "钱" to "关于金钱的梦境建议您审视资源管理和价值观。评估当前财务状况，确保资源分配符合真正的优先事项，记住财富不仅限于物质。",
            "房子" to "房子梦提醒您关注安全感和自我认同。思考如何创造更舒适的生活环境，无论物理空间还是心理空间，都应反映真实的自我。",
            "车" to "车辆梦鼓励您思考人生方向和控制感。评估当前路径是否符合真实目标，学习在保持方向的同时，也能灵活应对路上的变化。",
            "婚礼" to "婚礼梦提示您关注承诺和人生转变。思考当前的承诺是否符合内心期望，准备好迎接新阶段，同时确保决定基于真实意愿而非外界压力。",
            "工作" to "工作梦境建议您平衡职业抱负和个人满足感。评估工作压力来源，明确职业目标，确保职业道路与个人价值观一致。",
            "旅行" to "旅行梦鼓励您拥抱变化和新体验。可以计划实际旅行，或在日常生活中寻找小冒险，保持好奇心，拓宽视野。",
            "鬼" to "鬼怪梦境提醒您面对内心恐惧。勇敢审视那些被忽视或压抑的情绪，允许自己感受不适，然后寻找健康方式释放和转化。",
            "怪物" to "怪物梦境鼓励您正视内心阴暗面。接纳这些'阴影'作为自我的一部分，理解它们的根源，寻找健康方式整合这些能量。",
            "名人" to "名人梦提示您反思自我认同和抱负。思考梦中名人代表的品质如何反映您的渴望，寻找机会在现实中培养这些特质。",
            "前任" to "前任梦境建议您处理未解决的感情。允许自己感受和接纳这些情绪，从过往关系中学习，然后有意识地释放，为未来腾出空间。",
            "陌生人" to "陌生人梦鼓励您探索未知可能性。对新关系和体验保持开放，同时认识自我的不同面向，拥抱成长和变化。",
            "食物" to "食物梦提醒您关注身心滋养。思考哪些方面需要'喂养'——身体、心灵、关系或创造力，确保各方面需求得到平衡满足。",
            "学校" to "学校梦鼓励终身学习和成长。反思哪些领域您希望提升，制定学习计划，同时记住真正的成长不仅关乎成绩，也关乎全面发展。",
            "医院" to "医院梦提醒您关注健康和自我修复。审视身心需求，寻找适当方式放松和恢复，记住休息也是生产力的一部分。",
            "战争" to "战争梦境建议您关注内心和外部冲突。识别冲突根源，学习健康的冲突解决方式，平衡坚持原则与灵活妥协。"
        )
        
        if (detectedDream.isNotEmpty() && dreamAdvices.containsKey(detectedDream)) {
            sb.append(dreamAdvices[detectedDream] ?: "")
            adviceProvided = true
        } else if (dreamContent != null) {
            // 尝试从梦境内容中识别关键词
            for ((keyword, advice) in dreamAdvices) {
                if (dreamContent.contains(keyword)) {
                    sb.append(advice)
                    adviceProvided = true
                    break
                }
            }
        }
        
        // 如果没有找到特定建议，提供通用建议
        if (!adviceProvided) {
            val generalAdvices = listOf(
                "建议您记录这个梦及其引发的感受，看看它如何与您的现实生活产生共鸣。梦境日记可以帮助识别模式和主题，加深自我了解。\n\n尝试在睡前进行短暂冥想，创造平静的心境有助于更有意义的梦境体验。记住，梦是潜意识的表达，倾听它们可能带来意想不到的洞见。",
                
                "这个梦可能在提示您关注生活平衡。评估工作、关系、健康和个人成长各方面，看是否有被忽视的领域需要更多关注。\n\n在日常生活中留出时间进行反思，无论是通过冥想、散步还是创造性活动，都能帮助整合梦境带来的启示。",
                
                "建议您思考梦境中的情绪如何与现实生活中的感受相连。情绪常常是重要信息的载体，值得深入探索。\n\n尝试使用创造性方式（如绘画、写作或音乐）表达梦境体验，这可以帮助处理和理解潜意识内容，促进自我成长。",
                
                "这个梦提醒您关注内在需求和真实愿望。在做决定时，多问问自己'这真的是我想要的吗？'，确保选择符合内心价值观。\n\n修习正念可以增强对当下的觉察，帮助您更清晰地感知内在指引，无论是来自梦境还是直觉。"
            )
            
            sb.append(generalAdvices[random.nextInt(generalAdvices.size)])
        }
        
        // 引用经典解梦理论
        val classicQuotes = listOf(
            "正如《周公解梦》中所说：\"知梦则知命，解梦则解人。\"梦境是自我认识的重要窗口。",
            "古人云：\"日有所思，夜有所梦。\"梦常反映我们清醒时的思虑和关注。",
            "弗洛伊德认为：\"梦是通往无意识的皇家大道。\"通过解读梦境，我们能更好地理解自己。",
            "荣格指出：\"梦是潜意识自发而公正的自我表达。\"梦境常包含我们意识所忽略的智慧。",
            "东方传统认为：\"吉梦主吉，凶梦主凶，吉中有凶，凶中有吉。\"梦境解读应全面而辩证。"
        )
        
        sb.append("\n\n" + classicQuotes[random.nextInt(classicQuotes.size)])
        
        return sb.toString()
    }
    
    /**
     * 模拟周易预测响应
     */
    private fun simulateZhouYiResponse(question: String): String {
        try {
            val random = Random()
            val sb = StringBuilder()
            
            // 随机选择一个六十四卦
            val hexagrams = arrayOf("乾", "坤", "屯", "蒙", "需", "讼", "师", "比", "小畜", "履", "泰", "否",
                "同人", "大有", "谦", "豫", "随", "蛊", "临", "观", "噬嗑", "贲", "剥", "复",
                "无妄", "大畜", "颐", "大过", "坎", "离", "咸", "恒", "遁", "大壮", "晋", "明夷",
                "家人", "睽", "蹇", "解", "损", "益", "夬", "姤", "萃", "升", "困", "井",
                "革", "鼎", "震", "艮", "渐", "归妹", "丰", "旅", "巽", "兑", "涣", "节",
                "中孚", "小过", "既济", "未济")
            val hexagram = hexagrams[random.nextInt(hexagrams.size)]
            
            // 随机生成变爻
            val changedLines = mutableListOf<Int>()
            val changeCount = random.nextInt(3) // 0-2个变爻
            for (i in 0 until changeCount) {
                val line = random.nextInt(6) + 1 // 1-6爻
                if (!changedLines.contains(line)) {
                    changedLines.add(line)
                }
            }
            
            // 添加卦象部分
            sb.append("【卦象】\n")
            sb.append("您所求问的\"${question}\"，得到${hexagram}卦")
            if (changedLines.isNotEmpty()) {
                sb.append("，变爻在第${changedLines.joinToString("、")}爻")
            }
            sb.append("。\n\n")
            
            sb.append("${hexagram}卦象征着")
            // 为每个卦象添加一个简单描述
            when (hexagram) {
                "乾" -> sb.append("纯阳刚健，代表强大的创造力和领导力")
                "坤" -> sb.append("纯阴柔顺，代表包容和顺从")
                "屯" -> sb.append("初始阶段的困难和阻碍")
                "蒙" -> sb.append("蒙昧未开，需要启蒙和教育")
                // 添加更多卦象的描述...
                else -> sb.append("一种特定的能量状态，反映了您当前的处境和未来趋势")
            }
            sb.append("。\n\n")
            
            // 添加卦辞解析部分
            sb.append("【卦辞解析】\n")
            sb.append("《周易》中${hexagram}卦的卦辞是：\"")
            // 为常见卦象添加卦辞
            when (hexagram) {
                "乾" -> sb.append("元亨利贞")
                "坤" -> sb.append("元亨利牝马之贞")
                "屯" -> sb.append("元亨利贞，勿用有攸往，利建侯")
                "蒙" -> sb.append("亨。匪我求童蒙，童蒙求我。初筮告，再三渎，渎则不告。利贞")
                // 添加更多卦象的卦辞...
                else -> sb.append("此卦有其特定卦辞，表达了特定的哲理和指导")
            }
            sb.append("\"。\n\n")
            
            sb.append("这个卦辞的现代解释是：")
            when (hexagram) {
                "乾" -> sb.append("象征着宏图大展、事业兴旺的征兆。建议保持坚韧不拔的态度，遵循正道，自然能获得成功。")
                "坤" -> sb.append("象征着顺应自然、谦和包容的态度。像温顺的母马一样，稳健前行，不急不躁，自然会达到目的。")
                "屯" -> sb.append("表示虽然面临初始的困难，但最终会有所成就。建议暂时不要贸然行动，而是先打好基础，建立制度和规则。")
                "蒙" -> sb.append("象征蒙昧状态下需要启蒙和引导。如童蒙般纯真，需要适当的教育和指导。保持正道，不可反复无常。")
                // 添加更多卦象的解释...
                else -> sb.append("这个卦象揭示了您当前处境中的机遇和挑战，指导您如何应对当前局面以获得最佳结果。")
            }
            sb.append("\n\n")
            
            // 添加爻辞分析
            if (changedLines.isNotEmpty()) {
                sb.append("您的变爻是：")
                changedLines.forEach { line ->
                    sb.append("\n第${line}爻：")
                    // 随机生成爻辞解释
                    val lineDescriptions = arrayOf(
                        "这表示当前处于转变期，需要保持谨慎和耐心。",
                        "此爻象征即将到来的机遇，但需要有足够的准备才能把握。",
                        "此爻暗示您可能面临一些挑战，但通过坚持和努力能够克服。",
                        "这预示着一个积极的变化正在发生，保持开放心态。",
                        "此爻提醒您注意细节，不要忽视小事，它们可能带来重要影响。"
                    )
                    sb.append(lineDescriptions[random.nextInt(lineDescriptions.size)])
                }
                sb.append("\n\n")
            }
            
            // 添加情境解读部分
            sb.append("【情境解读】\n")
            sb.append("针对您的问题\"${question}\"，从${hexagram}卦的角度分析：\n\n")
            
            // 基于问题类型生成相关解读
            if (question.contains("事业") || question.contains("工作") || question.contains("职业")) {
                sb.append("在事业方面，${hexagram}卦预示")
                val careerReadings = arrayOf(
                    "您当前可能正面临职业转型的关键期。这个卦象建议您根据自身优势做出选择，不要盲目跟随他人的建议。现阶段适合沉淀自己，积累专业知识和技能，为未来的发展打下坚实基础。",
                    "工作上可能会遇到一些挑战，但这些挑战正是您成长的机会。这个卦象提醒您要保持坚韧的态度，不畏困难，积极寻求解决问题的方法。您的努力终将获得认可和回报。",
                    "职业发展处于上升期，但需要稳扎稳打。不要急于求成或跳槽，而是应该在现有岗位上不断提升自己的能力和价值。时机成熟时，晋升和发展自然会到来。",
                    "可能有新的工作机会即将出现，但需要您做好充分准备并保持警觉。这个卦象建议您提前完善自己的专业技能，扩展人际网络，以便在机会来临时能够把握住。"
                )
                sb.append(careerReadings[random.nextInt(careerReadings.size)])
            } else if (question.contains("感情") || question.contains("婚姻") || question.contains("爱情")) {
                sb.append("在感情方面，${hexagram}卦显示")
                val loveReadings = arrayOf(
                    "您的感情生活可能正处于转变期。这个卦象提醒您审视自己真正的情感需求，不要因为外界压力或者习惯而勉强维持不健康的关系。真正的感情需要双方的真诚付出和有效沟通。",
                    "感情中需要更多的耐心和理解。您可能期望立即看到改变，但感情的发展需要时间和双方的共同努力。这个卦象建议您放下急躁的心态，给彼此更多成长的空间。",
                    "良好的感情关系正在形成或增强。这个卦象预示着和谐与稳定，但仍需要您保持真诚的态度和有效的沟通。避免将小问题积累成大矛盾，及时表达自己的想法和感受。",
                    "可能需要面对一些感情上的困难或抉择。这个卦象提醒您内心的声音往往是最可靠的指引。无论做出什么决定，确保它符合您的真实意愿和长远幸福。"
                )
                sb.append(loveReadings[random.nextInt(loveReadings.size)])
            } else if (question.contains("财富") || question.contains("投资") || question.contains("钱财")) {
                sb.append("在财富方面，${hexagram}卦建议")
                val wealthReadings = arrayOf(
                    "近期的财务状况可能会有所波动，但不必过度担忧。这个卦象建议您建立合理的财务规划，增加收入来源的多样性，避免将所有资金投入单一项目。保持稳健的投资策略将帮助您渡过可能的不稳定期。",
                    "财务上应该更加谨慎和保守。这个卦象警示可能的风险和陷阱，建议您不要被短期利益诱惑而做出冲动决策。现阶段适合巩固已有成果，减少不必要的支出，积累财富。",
                    "有望获得财务上的突破或增长。但这个卦象提醒您，真正的财富来自于长期积累和明智管理，而非投机取巧。现在是制定长远财务目标和投资战略的好时机。",
                    "财务状况将随着您的努力逐步改善。这个卦象显示，踏实工作和理性消费是提升经济状况的关键。同时，保持开放心态，可能有意外的财富机会出现。"
                )
                sb.append(wealthReadings[random.nextInt(wealthReadings.size)])
            } else {
                sb.append("对于您的问题，${hexagram}卦给出的指引是：")
                val generalReadings = arrayOf(
                    "当前局面看似复杂，但实际上正在朝着有利的方向发展。这个卦象建议您保持耐心和信心，不要被表面的困难所干扰。坚持正确的方向，最终会看到积极的结果。",
                    "您可能正处于一个需要做出决策的关键时刻。这个卦象提醒您，明智的选择不仅基于眼前利益，更要考虑长远影响。倾听内心的声音，它通常能给出最适合您的指引。",
                    "当前局面存在一些不确定性，但这也意味着有新的可能性。这个卦象建议您保持灵活的心态，准备适应可能的变化。同时，不要忽视细节，它们可能包含重要信息。",
                    "面对的挑战虽然艰巨，但您具备克服它们的能力。这个卦象鼓励您发挥自身优势，寻求必要的帮助，勇敢面对困难。每一次挑战都是成长的机会。"
                )
                sb.append(generalReadings[random.nextInt(generalReadings.size)])
            }
            sb.append("\n\n")
            
            // 添加传统智慧引用
            sb.append("《易经》有云：\"")
            val wisdomQuotes = arrayOf(
                "天行健，君子以自强不息",
                "地势坤，君子以厚德载物",
                "善不积不足以成名，恶不积不足以灭身",
                "君子藏器于身，待时而动",
                "知几其神乎，君子上交不谄，下交不渎",
                "与时偕行，随时处变",
                "天地之大德曰生",
                "君子以俭德辟难"
            )
            val selectedQuote = wisdomQuotes[random.nextInt(wisdomQuotes.size)]
            sb.append(selectedQuote)
            sb.append("\"，这一古老智慧在您当前的情况中尤为适用。\n\n")
            
            // 添加建议部分
            sb.append("【建议】\n")
            sb.append("基于${hexagram}卦的启示，给您的具体建议是：\n\n")
            
            // 随机生成几点建议
            val adviceCount = 3 + random.nextInt(3) // 3-5点建议
            val advicePool = arrayOf(
                "保持内心的平静和耐心，不要被短期的波动所干扰。",
                "审慎决策，避免冲动行事，确保每一步都经过深思熟虑。",
                "寻求值得信任的人的建议，但最终的决定应该由自己做出。",
                "增强自身能力和知识，为未来的机会做好准备。",
                "避免过度担忧未知的结果，专注于当下能够掌控的事情。",
                "保持灵活的心态，准备好适应可能的变化和调整。",
                "在合适的时机表达自己的想法和感受，避免积累负面情绪。",
                "建立合理的计划和目标，逐步推进，不要期望一蹴而就。",
                "在做出重要决定前，确保考虑了所有可能的后果和影响。",
                "平衡工作与休息，保持身心健康，这是成功的基础。",
                "寻找能够激发您热情和创造力的活动，它们可以带来新的视角和灵感。",
                "不要害怕改变和挑战，它们往往是成长和进步的催化剂。"
            )
            
            for (i in 1..adviceCount) {
                var advice = advicePool[random.nextInt(advicePool.size)]
                while (sb.toString().contains(advice)) { // 避免重复建议
                    advice = advicePool[random.nextInt(advicePool.size)]
                }
                sb.append("${i}. $advice\n")
            }
            sb.append("\n")
            
            // 添加总结部分
            sb.append("【总结】\n")
            sb.append("简单来说，")
            
            // 根据卦象生成总结
            val summaryByHexagram = mapOf(
                "乾" to "您现在正处于充满活力和潜力的阶段，要保持坚定不移的毅力和自信心。只要按照正确的方向努力，一定能取得成功。说白了，就是坚持做对的事，不要轻易放弃，好运气自然会来敲门。",
                "坤" to "现在需要您保持谦逊和包容的态度，顺应形势发展。就像大地一样，不声不响地承载万物，却成就了巨大的功业。简单说，先别着急表现自己，默默积累实力，时机成熟时再出手。",
                "屯" to "您目前面临的困难是暂时的，就像春天的种子刚刚破土，看似弱小却充满生机。关键是不要急着求成，而是要打好基础。用大白话说，眼下可能有点艰难，但挺过去就是一片光明，关键是别放弃。"
            )
            
            val defaultSummaries = arrayOf(
                "这个周易卦象告诉我们，您现在所处的局面虽然有一定挑战，但只要按照建议行事，问题会迎刃而解。换句话说，别太担心，按部就班地做事，结果自然会好。",
                "简单总结一下，您现在需要的是耐心和毅力，而不是立竿见影的方法。踏实走好每一步，不急不躁，自然能看到好结果。",
                "说白了，这个卦象是在提醒您，现在最重要的是保持清醒的头脑，不要被情绪左右。冷静分析，理性决策，事情就会向好的方向发展。",
                "总的来说，周易提醒您现在是蓄势待发的时候，不要急于求成。做好准备工作，等待合适的时机，成功就在不远处等着您。"
            )
            
            sb.append(summaryByHexagram.getOrDefault(hexagram, defaultSummaries[random.nextInt(defaultSummaries.size)]))
            
            return sb.toString()
        } catch (e: Exception) {
            Log.e(TAG, "生成周易模拟响应时出错", e)
            return """
                【卦象】
                模拟周易卦象生成过程中出现错误。
                
                【卦辞解析】
                由于技术原因，无法提供完整解析。这可能是由于系统临时故障或数据处理问题。
                
                【建议】
                1. 请重新尝试占卜
                2. 如果问题持续，可以尝试使用其他占卜方式
                3. 确保输入的问题清晰明确
                
                【总结】
                简单说，系统现在遇到了点小问题，建议您稍后再试，或者换个算命方式。
            """
        }
    }
        }
        
        // 如果只有一个组或组过多，使用简单分段
        if (groups.size == 1 || groups.size > 5) {
            // 简单地按长度分为2-3段
            val segmentCount = if (totalLines > 15) 3 else 2
            val segmentSize = totalLines / segmentCount
            
            for (i in 0 until segmentCount) {
                val start = i * segmentSize
                val end = if (i == segmentCount - 1) totalLines else (i + 1) * segmentSize
                val title = if (segmentCount > 1) "$baseTitle ${toRomanNumeral(i + 1)}" else baseTitle
                result.add(ResultSection(
                    title,
                    lines.subList(start, end).joinToString("\n")
                ))
            }
        } else {
            // 使用分组结果
            for ((i, group) in groups.withIndex()) {
                if (group.isEmpty()) continue
                
                // 尝试识别组标题
                val groupTitle = if (i == 0) {
                    baseTitle
                } else if (group[0].length < 20 && (group[0].endsWith("：") || group[0].endsWith(":") ||
                    group[0].startsWith("-") || group[0].startsWith("*"))) {
                    group[0].replace(Regex("^[-*\\s]+"), "").trim()
                } else {
                    "$baseTitle ${toRomanNumeral(i + 1)}"
                }
                
                result.add(ResultSection(groupTitle, group.joinToString("\n")))
            }
        }
        
        return result
    }
    
    /**
     * 为周公解梦内容创建合理的分段
     */
    private fun splitDreamContent(content: String): List<ResultSection> {
        val sections = mutableListOf<ResultSection>()
        
        try {
            // 周公解梦解析的几个典型部分
            val lines = content.split("\n").filter { it.trim().isNotEmpty() }
            
            if (lines.isEmpty()) {
                // 如果内容为空，返回一个默认部分
                sections.add(ResultSection("解梦分析", "无法解析内容，请重新尝试"))
                return sections
            }
            
            if (lines.size <= 1) {
                // 如果只有一行内容，直接作为"解梦分析"
                sections.add(ResultSection("解梦分析", content.trim()))
                return sections
            }
            
            // 检查内容中是否已经有明确的标题段落
            val titlePattern = Regex("(【|\\[|\\(|「|『)(.*?)(】|\\]|\\)|」|』)")
            val hasTitles = lines.any { titlePattern.find(it) != null }
            
            if (hasTitles) {
                // 如果已经有标题格式，按现有标题分段
                var currentTitle = "梦境概要"
                val tempSections = mutableMapOf<String, MutableList<String>>()
                tempSections[currentTitle] = mutableListOf()
                
                for (line in lines) {
                    val titleMatch = titlePattern.find(line)
                    if (titleMatch != null) {
                        // 找到新标题
                        currentTitle = titleMatch.groupValues[2].trim()
                        if (!tempSections.containsKey(currentTitle)) {
                            tempSections[currentTitle] = mutableListOf()
                        }
                        // 添加不包含标题符号的内容
                        val remainingContent = line.replaceFirst(titleMatch.value, "").trim()
                        if (remainingContent.isNotEmpty()) {
                            tempSections[currentTitle]?.add(remainingContent)
                        }
                    } else {
                        // 继续添加到当前标题
                        tempSections[currentTitle]?.add(line)
                    }
                }
                
                // 将临时段落转换为最终结果
                for ((title, contentLines) in tempSections) {
                    if (contentLines.isNotEmpty()) {
                        sections.add(ResultSection(title, contentLines.joinToString("\n")))
                    }
                }
            } else {
                // 如果没有明确标题，使用关键词来分段
                val overviewLines = mutableListOf<String>()
                val interpretationLines = mutableListOf<String>()
                val symbolLines = mutableListOf<String>()
                val psychoLines = mutableListOf<String>()
                val adviceLines = mutableListOf<String>()
                
                var currentSection = overviewLines
                
                // 基于关键词对内容进行分类
                for (line in lines) {
                    when {
                        line.contains("梦境概要") || line.contains("梦境简述") || line.contains("梦境描述") || 
                        line.contains("总体") || line.contains("概览") || line.contains("简述") -> {
                            currentSection = overviewLines
                        }
                        line.contains("象征") || line.contains("象征意义") || line.contains("象征物") -> {
                            currentSection = symbolLines
                        }
                        line.contains("心理") || line.contains("心理分析") || line.contains("心理学解释") -> {
                            currentSection = psychoLines
                        }
                        line.contains("解析") || line.contains("解梦") || line.contains("解释") || 
                        line.contains("传统") || line.contains("传统解释") || line.contains("民间") -> {
                            currentSection = interpretationLines
                        }
                        line.contains("建议") || line.contains("忠告") || line.contains("指引") || 
                        line.contains("提示") || line.contains("行动") -> {
                            currentSection = adviceLines
                        }
                    }
                    
                    currentSection.add(line)
                }
                
                // 根据内容分配段落
                if (overviewLines.isNotEmpty()) {
                    sections.add(ResultSection("梦境概要", overviewLines.joinToString("\n")))
                }
                
                if (symbolLines.isNotEmpty()) {
                    sections.add(ResultSection("象征意义", symbolLines.joinToString("\n")))
                }
                
                if (interpretationLines.isNotEmpty()) {
                    sections.add(ResultSection("梦境解析", interpretationLines.joinToString("\n")))
                }
                
                if (psychoLines.isNotEmpty()) {
                    sections.add(ResultSection("心理分析", psychoLines.joinToString("\n")))
                }
                
                if (adviceLines.isNotEmpty()) {
                    sections.add(ResultSection("建议", adviceLines.joinToString("\n")))
                }
            }
            
            // 如果没有找到任何分段，尝试智能分段
            if (sections.isEmpty()) {
                // 尝试智能分段：按段落长度切分
                if (lines.size >= 10) {
                    // 基本的三部分分段
                    val totalLines = lines.size
                    val firstPartEnd = (totalLines * 0.3).toInt().coerceAtLeast(3)
                    val secondPartEnd = (totalLines * 0.7).toInt().coerceAtMost(totalLines - 3)
                    
                    sections.add(ResultSection(
                        "梦境概述", 
                        lines.subList(0, firstPartEnd).joinToString("\n")
                    ))
                    
                    sections.add(ResultSection(
                        "解析", 
                        lines.subList(firstPartEnd, secondPartEnd).joinToString("\n")
                    ))
                    
                    sections.add(ResultSection(
                        "建议", 
                        lines.subList(secondPartEnd, totalLines).joinToString("\n")
                    ))
                } else {
                    // 内容较少，直接添加为一个部分
                    sections.add(ResultSection("梦境解析", content.trim()))
                }
            }
            
        } catch (e: Exception) {
            // 如果解析出现异常，返回原文本作为一个分段
            Log.e(TAG, "解梦分段处理异常", e)
            sections.add(ResultSection("梦境解析", content.trim()))
        }
        
        return sections
    }
    
    /**
     * 将单个大段落细分为多个小段落
     */
    private fun subdivideSection(title: String, contentLines: List<String>): List<ResultSection> {
        val result = mutableListOf<ResultSection>()
        
        try {
            // 如果段落很短，直接返回
            if (contentLines.size <= 10) {
                result.add(ResultSection(title, contentLines.joinToString("\n")))
                return result
            }
            
            // 尝试基于内容主题进行分段
            val subSections = mutableListOf<Pair<String, MutableList<String>>>()
            var currentSubTitle = "$title I"
            var currentSubContent = mutableListOf<String>()
            
            // 关键词映射表，用于检测子主题
            val keywordMap = mapOf(
                "梦境概述" to listOf("梦的基本含义", "梦境象征", "梦的背景", "梦的主题", "梦的情绪"),
                "传统解读" to listOf("周公解梦", "古代观点", "传统象征", "吉凶寓意", "古籍记载", "民间传说", "传统文化"),
                "现代解析" to listOf("心理学视角", "弗洛伊德", "荣格", "潜意识", "象征意义", "情感投射", "压力反映"),
                "启示与建议" to listOf("建议", "指导", "行动方案", "注意事项", "提醒", "解决方法", "积极方面", "消极方面")
            )
            
            // 查找可能的分段点
            val potentialBreakPoints = mutableListOf<Int>()
            
            // 基于段落长度和内容划分
            for (i in contentLines.indices) {
                val line = contentLines[i]
                
                // 检查是否包含与主标题相关的关键词
                val relevantKeywords = keywordMap[title] ?: emptyList()
                if (relevantKeywords.any { keyword -> line.contains(keyword) }) {
                    potentialBreakPoints.add(i)
                }
                
                // 检查是否是短段落的开头（表示可能是新主题）
                if (line.length < 15 && i < contentLines.size - 1 && 
                    (line.endsWith("：") || line.endsWith(":") || 
                     line.contains("首先") || line.contains("其次") || 
                     line.contains("此外") || line.contains("最后") || 
                     line.contains("总的来说") || line.contains("总的来讲") || 
                     line.contains("值得注意的是") || line.contains("特别提醒"))) {
                    potentialBreakPoints.add(i)
                }
                
                // 如果遇到明显的分隔符
                if (line.startsWith("---") || line.startsWith("***") || line.startsWith("===") || 
                    line == "•" || line == "·" || line == "⊙" || line == "☉" || line == "◆") {
                    potentialBreakPoints.add(i)
                }
            }
            
            // 如果没有找到自然分段点，根据段落长度均匀分割
            if (potentialBreakPoints.isEmpty() || potentialBreakPoints.size == 1) {
                val idealSubSectionSize = 5 // 理想的小段落大小
                val numSubSections = max(2, contentLines.size / idealSubSectionSize)
                
                // 均匀分段
                val avgSize = contentLines.size / numSubSections
                for (i in 0 until numSubSections) {
                    val startIdx = i * avgSize
                    val endIdx = if (i == numSubSections - 1) contentLines.size else (i + 1) * avgSize
                    
                    val subTitle = if (numSubSections > 1) "$title ${toRomanNumeral(i + 1)}" else title
                    val subContent = contentLines.subList(startIdx, endIdx).joinToString("\n")
                    
                    result.add(ResultSection(subTitle, subContent))
                }
            } else {
                // 添加第一个子段落（从开始到第一个分段点）
                if (potentialBreakPoints[0] > 0) {
                    val subTitle = "$title I"
                    val subContent = contentLines.subList(0, potentialBreakPoints[0]).joinToString("\n")
                    result.add(ResultSection(subTitle, subContent))
                }
                
                // 添加中间的子段落
                for (i in 0 until potentialBreakPoints.size - 1) {
                    val startIdx = potentialBreakPoints[i]
                    val endIdx = potentialBreakPoints[i + 1]
                    
                    val subTitle = "$title ${toRomanNumeral(i + 2)}" // +2因为第一个已经是I了
                    val subContent = contentLines.subList(startIdx, endIdx).joinToString("\n")
                    result.add(ResultSection(subTitle, subContent))
                }
                
                // 添加最后一个子段落（从最后一个分段点到结束）
                val lastBreakPoint = potentialBreakPoints.last()
                if (lastBreakPoint < contentLines.size - 1) {
                    val subTitle = "$title ${toRomanNumeral(potentialBreakPoints.size + 1)}"
                    val subContent = contentLines.subList(lastBreakPoint, contentLines.size).joinToString("\n")
                    result.add(ResultSection(subTitle, subContent))
                }
            }
            
            // 如果经过处理后仍然没有分段，返回原始段落
            if (result.isEmpty()) {
                result.add(ResultSection(title, contentLines.joinToString("\n")))
            }
            
        } catch (e: Exception) {
            // 出错时返回原始段落
            Log.e(TAG, "细分段落异常", e)
            result.add(ResultSection(title, contentLines.joinToString("\n")))
        }
        
        return result
    }
    
    /**
     * 将数字转换为罗马数字
     */
    private fun toRomanNumeral(num: Int): String {
        return when (num) {
            1 -> "I"
            2 -> "II"
            3 -> "III"
            4 -> "IV"
            5 -> "V"
            6 -> "VI"
            7 -> "VII"
            8 -> "VIII"
            9 -> "IX"
            10 -> "X"
            else -> num.toString()
        }
    }
    
    /**
     * 使用协程发送邮件
     * 
     * @param subject 邮件主题
     * @param body 邮件内容
     * @param toEmail 收件人邮箱，默认为FEEDBACK_EMAIL
     * @return 发送成功返回true，否则返回false
     */
    suspend fun sendEmail(
        subject: String, 
        body: String, 
        toEmail: String = AppConfig.EmailConfig.FEEDBACK_EMAIL
    ): Boolean {
        // 使用EmailSender发送邮件
        return EmailSender.sendEmail(subject, body, toEmail)
    }
    
    /**
     * 从内容中提取可能的标题
     */
    private fun extractTitleFromContent(content: String): String {
        // 尝试从内容中提取标题
        val lines = content.split("\n")
        if (lines.isNotEmpty()) {
            val firstLine = lines[0].trim()
            if (firstLine.length < 30) {
                return firstLine
            }
        }
        return "解析"
    }
    
    /**
     * 将响应文本解析为多个部分
     * 将响应文本拆分为多个部分
     * 可以从外部调用，用于处理模拟函数返回的结果
     * 添加全面的异常处理，确保不会因解析错误导致应用崩溃
     */
    fun parseResponseToSections(content: String): List<ResultSection> {
        val sections = mutableListOf<ResultSection>()
        
        try {
            // 检查内容是否为空
            if (content.isBlank()) {
                sections.add(ResultSection("结果", "无法获取有效内容"))
                return sections
            }
            
            // 尝试根据标题格式分段
            val titlePattern = "【([^】]+)】|\\[([^\\]]+)\\]|^(.*?)[：:]".toRegex(RegexOption.MULTILINE)
            val titleMatches = titlePattern.findAll(content)
            
            // 如果找到标题格式的分隔符
            if (titleMatches.count() > 0) {
                var currentTitle = "概述"
                var currentContent = StringBuilder()
                var lastIndex = 0
                
                for (match in titleMatches) {
                    // 如果不是第一个标题，保存上一部分内容
                    if (match.range.first > lastIndex && currentContent.isNotEmpty()) {
                        sections.add(ResultSection(currentTitle, currentContent.toString().trim()))
                        currentContent = StringBuilder()
                    }
                    
                    // 提取新标题
                    currentTitle = match.groupValues[1].ifEmpty { 
                        match.groupValues[2].ifEmpty { match.groupValues[3] }
                    }
                    
                    // 提取此标题下的内容
                    val titleEnd = match.range.last + 1
                    val nextMatchStart = titleMatches.find { it.range.first > titleEnd }?.range?.first ?: content.length
                    
                    if (nextMatchStart > titleEnd) {
                        currentContent.append(content.substring(titleEnd, nextMatchStart))
                    }
                    
                    lastIndex = nextMatchStart
                }
                
                // 添加最后一部分
                if (currentContent.isNotEmpty()) {
                    sections.add(ResultSection(currentTitle, currentContent.toString().trim()))
                }
            } else {
                // 没有找到标准格式的标题，尝试智能分段
                val lines = content.split("\n").filter { it.trim().isNotEmpty() }
                
                // 如果内容很短，直接添加为一个部分
                if (lines.size <= 5) {
                    sections.add(ResultSection("结果", content.trim()))
                } else {
                    // 根据内容长度，尝试将其分为2-3个部分
                    val partCount = if (lines.size > 15) 3 else 2
                    val partSize = lines.size / partCount
                    
                    for (i in 0 until partCount) {
                        val start = i * partSize
                        val end = if (i == partCount - 1) lines.size else (i + 1) * partSize
                        
                        // 尝试为每个部分找一个合适的标题
                        val partTitle = when (i) {
                            0 -> "综合分析"
                            partCount - 1 -> "建议"
                            else -> "详细解读"
                        }
                        
                        val partContent = lines.subList(start, end).joinToString("\n")
                        sections.add(ResultSection(partTitle, partContent))
                    }
                }
            }
            
            // 检查是否生成了有效的部分
            if (sections.isEmpty()) {
                sections.add(ResultSection("结果", content.trim()))
            }
            
            return sections
        } catch (e: Exception) {
            // 出现任何异常，记录错误并返回简单的结果
            Log.e(TAG, "解析响应文本出错", e)
            sections.add(ResultSection("结果", "解析内容时出现错误，原始内容如下：\n\n${content.take(1000)}"))
            return sections
        }
    }
    
    /**
     * 分割周易内容为多个部分
     */
    private fun splitZhouYiContent(content: String): List<ResultSection> {
        val sections = mutableListOf<ResultSection>()
        
        try {
            // 增加日志记录，便于调试
            Log.d(TAG, "开始解析周易内容，长度: ${content.length}")
            
            // 首先检查内容是否为空
            if (content.isBlank()) {
                Log.e(TAG, "周易内容为空!")
                sections.add(ResultSection("提示", "未能生成有效的周易卦象解析"))
                return sections
            }
            
            // 尝试使用标准格式进行分段
            val sectionPattern = "【([^】]+)】([\\s\\S]*?)(?=【[^】]+】|$)"
            val matcher = Pattern.compile(sectionPattern).matcher(content)
            
            var found = false
            
            // 查找所有使用【】格式的部分
            while (matcher.find()) {
                found = true
                val title = matcher.group(1)?.trim() ?: "周易解析"
                val sectionContent = matcher.group(2)?.trim() ?: ""
                
                // 只有当标题和内容都不为空时才添加到结果中
                if (title.isNotBlank() && sectionContent.isNotBlank()) {
                    sections.add(ResultSection(title, sectionContent))
                }
            }
            
            // 如果没有找到标准格式，尝试其他方式
            if (!found) {
                // 尝试使用默认解析方法
                Log.w(TAG, "周易内容未使用标准【】格式，尝试其他解析方式")
                return parseResponseToSections(content)
            }
            
            // 确保至少返回一个部分
            if (sections.isEmpty()) {
                Log.w(TAG, "解析结果为空，使用简化解析")
                
                // 尝试简单分段
                val lines = content.split("\n")
                val plainText = lines.joinToString("\n")
                
                // 至少返回一个基本部分
                sections.add(ResultSection("卦象解析", plainText))
            }
            
            // 记录日志
            Log.d(TAG, "周易内容解析完成，生成 ${sections.size} 个部分")
            
            return sections
        } catch (e: Exception) {
            // 捕获所有可能的异常
            Log.e(TAG, "分割周易内容时出错", e)
            
            // 确保返回非空结果
            if (sections.isEmpty()) {
                try {
                    // 尝试使用最简单的文本分割
                    val plainText = content.replace("【", "===").replace("】", "===")
                    val parts = plainText.split("===")
                    
                    if (parts.size > 2) {
                        // 有可能分离出标题和内容
                        var i = 0
                        while (i < parts.size - 1) {
                            val title = parts[i].trim()
                            val content = parts[i + 1].trim()
                            
                            if (title.isNotBlank() && content.isNotBlank()) {
                                sections.add(ResultSection(title, content))
                            }
                            
                            i += 2
                        }
                    }
                    
                    // 如果还是没有有效部分，添加整个内容
            if (sections.isEmpty()) {
                        sections.add(ResultSection("周易解析", content))
                    }
                } catch (ex: Exception) {
                    // 真的出错了，返回错误信息
                    Log.e(TAG, "无法解析周易内容：${ex.message}")
                    sections.add(ResultSection("解析错误", "无法解析卦象内容，请重试"))
                }
            }
            
            return sections
        }
    }
    
    /**
     * 解析API响应，生成占卜结果对象
     * 增加全面的异常处理以防应用崩溃
     */
    private fun parseResponse(method: DivinationMethod, inputData: Map<String, String>, response: String): DivinationResult {
        try {
            // 根据不同算命方法处理响应
            var sections = when (method.id) {
                "zhouyi" -> {
                    val zhouYiSections = splitZhouYiContent(response)
                    if (zhouYiSections.isEmpty()) {
                        // 如果解析结果为空，添加默认内容防止空白页面
                        Log.w(TAG, "周易解析结果为空，使用备用内容")
                        listOf(
                            ResultSection(
                                title = "卦象",
                                content = "本次预测得到了周易卦象，但内容解析出现问题。"
                            ),
                            ResultSection(
                                title = "解析",
                                content = "卦象内容解析失败，请重新尝试。可能是格式不兼容或数据问题导致。\n\n如果问题持续存在，请尝试其他算命方式。"
                            ),
                            ResultSection(
                                title = "原始内容",
                                content = response.take(500)
                            )
                        )
                    } else {
                        zhouYiSections
                    }
                }
                "dream" -> splitDreamContent(response)
                "tarot" -> {
                    // 对塔罗牌响应进行特殊处理
                    val baseSection = parseResponseToSections(response)
                    baseSection.flatMap { section -> 
                        subdivideTarotSection(section.title, section.content.split("\n"))
                    }
                }
                else -> parseResponseToSections(response)
            }
            
            // 确保所有方法都至少有一个有效部分
            if (sections.isEmpty()) {
                Log.w(TAG, "${method.id}方法解析结果为空，添加默认内容")
                sections = listOf(
                    ResultSection(
                        title = "解析结果",
                        content = "无法生成有效的解析内容。这可能是由于数据格式问题或系统临时故障导致。\n\n请稍后重试或选择其他算命方式。"
                    )
                )
            }
            
            // 创建并返回占卜结果对象
            return DivinationResult(
                id = UUID.randomUUID().toString(),
                methodId = method.id,
                createTime = Date(),
                inputData = inputData,
                resultSections = sections
            )
        } catch (e: Exception) {
            // 出现异常时创建一个错误结果
            Log.e(TAG, "解析响应出错: ${e.message}", e)
            val errorSections = listOf(
                ResultSection(
                title = "错误提示",
                    content = "处理结果时出错: ${e.message}\n\n请重试或选择其他算命方式。"
                )
            )
            
            return DivinationResult(
                id = UUID.randomUUID().toString(),
                methodId = method.id,
                createTime = Date(),
                inputData = inputData,
                resultSections = errorSections
            )
        }
    }
}